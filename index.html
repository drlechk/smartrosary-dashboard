<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" type="image/svg+xml" href="favicon.svg">
<title>Smart Rosary — Dashboard</title>
<style>
  :root { color-scheme: dark; }
  * { box-sizing: border-box; }
  body {
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI",
                 Roboto, Ubuntu, "Helvetica Neue", Arial, sans-serif;
    margin:0; background:#0b0f14; color:#eaf0f6; overflow-x:hidden;
  }
  header {
    padding:18px 16px; text-align:center; border-bottom:1px solid #18212b; background:#0e141b;
  }
  h1 { margin:0; font-size:20px; font-weight:700; letter-spacing:.2px; }
  .toolbar-wrap { display:flex; justify-content:center; }
  .toolbar {
    display:flex; gap:8px; padding:12px; flex-wrap:wrap; align-items:center;
    width:100%; max-width: 980px;
  }
  button, select {
    border:0; border-radius:10px; padding:10px 14px; font-weight:600; cursor:pointer;
    transition:transform .05s ease; background:#1f2937; color:#eaf0f6;
  }
  button:active { transform:scale(0.98); }
  #connectBtn     { background:#03a9f4; color:#001018; }
  #refreshBtn     { background:#1f2937; }
  #backupBtn      { background:#0ea5e9; color:#001018; }
  #restoreBtn     { background:#16a34a; color:#00150b; }
  #disconnectBtn  { background:#b91c1c; color:#fff; }
  #resetBtn       { background:#9c27b0; color:#fff; }
  #langSelect     { background:#0f1720; border:1px solid #1f2b3a; }
  #status { text-align:center; color:#95a7ba; font-size:13px; padding-bottom:8px; }
  .wrap { max-width: 980px; margin: 0 auto; padding: 16px; }
  .grid { display:grid; gap:16px; grid-template-columns: repeat(2, minmax(280px, 1fr)); }
  @media (max-width: 800px) { .grid { grid-template-columns: 1fr; } }
  .card {
    background:#101722; border:1px solid #1a2733; border-radius:14px; padding:16px;
    box-shadow:0 6px 24px rgba(0,0,0,.25);
  }
  .card h3 { margin:0 0 12px; font-size:16px; font-weight:700; color:#cfe4ff; }
  .kpis { display:grid; grid-template-columns:repeat(2,1fr); gap:10px; }
  .kpi { background:#0d131c; border:1px solid #172231; border-radius:12px; padding:10px 12px; }
  .kpi .label { color:#9fb3c8; font-size:12px; }
  .kpi .value { font-size:18px; font-weight:800; margin-top:2px; line-height:1.1; }
  .pill {
    display:inline-block; background:#0d2030; border:1px solid #1d3551;
    color:#cde3ff; padding:6px 10px; border-radius:999px; font-size:13px;
  }
  .flex { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  .muted { color:#95a7ba; font-size:12px; }
  .smallnote { color:#7d8fa1; font-size:11px; margin-top:8px; }
  .chart { position:relative; width:100%; height:260px; }
  canvas { display:block; width:100%; height:100%; }

  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  #restoreProg {
    width:100%; height:10px; background:#0d131c; border:1px solid #172231; border-radius:999px; overflow:hidden;
    margin-top:8px;
  }
</style>
</head>
<body>
  <header>
    <h1 id="titleTxt">Smart Rosary — Dashboard</h1>
  </header>

  <div class="toolbar-wrap">
    <div class="toolbar">
      <button id="connectBtn">Connect</button>
      <button id="refreshBtn" disabled>Refresh</button>
      
      <div class="row"></div>

      <button id="disconnectBtn" disabled>Disconnect</button>
      <span style="flex:1"></span>
      <label for="langSelect" class="muted" style="font-weight:600;margin-right:6px;">Language</label>
      <select id="langSelect">
        <option value="en">English</option>
        <option value="pl">Polski</option>
        <option value="de">Deutsch</option>
      </select>
    </div>
  </div>

  <div id="status">Not connected.</div>

  <section class="wrap">
    <div class="grid">
      <div class="card">
        <h3 id="overviewTitle">Overview</h3>
        <div class="kpis" style="grid-template-columns:repeat(3,1fr);">
          <div class="kpi"><div class="label" id="lblBeads">Beads</div><div class="value" id="kpiBeads">—</div></div>
          <div class="kpi"><div class="label" id="lblDecades">Decades</div><div class="value" id="kpiDecades">—</div></div>
          <div class="kpi"><div class="label" id="lblRosaries">Rosaries</div><div class="value" id="kpiRosaries">—</div></div>
          <div class="kpi"><div class="label" id="lblChaplets">Chaplets</div><div class="value" id="kpiChaplets">—</div></div>
        </div>
        <div class="flex" style="margin-top:12px;">
          <span class="pill" id="pillDevice"><span id="lblDevice">Device</span>: <span id="valDevice">—</span></span>
          <span class="pill" id="pillFW"><span id="lblFW">FW</span>: <span id="valFW">—</span></span>
          <span class="pill" id="pillLastMystery"><span id="lblLastMystery">Last mystery</span>: <span id="valLastMystery">—</span></span>
        </div>
        <p class="smallnote" id="bkNote"></p>
        <h3>Backup & Restore</h3>
        <div class="row">
          <button id="backupBtn"  disabled>Download</button>
          <input type="file" id="restoreFile" accept="application/json" style="display:none">
          <button id="restoreBtn" disabled>Restore</button>
          <button id="resetBtn" disabled>Reset Statistics</button>
          <progress id="restoreProg" max="100" value="0" hidden></progress>
        </div>
      </div>

      <div class="card">
        <h3 id="avgTitle">Durations & Averages</h3>
         <div class="kpis" style="grid-template-columns:repeat(3,1fr);">
          <div class="kpi"><div class="label" id="lblAvgBead">Avg bead</div><div class="value" id="kpiAvgBead">—</div></div>
          <div class="kpi"><div class="label" id="lblAvgDecade">Avg decade</div><div class="value" id="kpiAvgDecade">—</div></div>
          <div class="kpi"><div class="label" id="lblAvgRosary">Avg rosary</div><div class="value" id="kpiAvgRosary">—</div></div>
          <div class="kpi"><div class="label" id="lblAvgChaplet">Avg chaplet</div><div class="value" id="kpiAvgChaplet">—</div></div>
        </div>
        <p class="smallnote" id="avgNote">Averages are computed from lifetime device totals.</p>
        <h3 id="totalsTitle">Totals (time)</h3>
        <div class="kpis" style="grid-template-columns:repeat(3,1fr);">
          <div class="kpi"><div class="label" id="lblTrosary">Rosary</div><div class="value" id="totRosary">—</div></div>
          <div class="kpi"><div class="label" id="lblTdecades">Decades</div><div class="value" id="totDecade">—</div></div>
          <div class="kpi"><div class="label" id="lblTbeads">Beads</div><div class="value" id="totBead">—</div></div>
          <div class="kpi"><div class="label" id="lblTchaplet">Chaplet</div><div class="value" id="totChaplet">—</div></div>
        </div>
      </div>

      <div class="card">
        <h3 id="barTitle">Average durations (s)</h3>
        <div class="chart"><canvas id="barWindow"></canvas></div>
      </div>

      <div class="card">
        <h3 id="donutTitle">Mystery Sets Breakdown</h3>
        <div class="chart"><canvas id="donutSets"></canvas></div>
      </div>

      <div class="card">
        <h3 id="partsTitle">Mystery Parts (I–V per set)</h3>
        <div class="chart"><canvas id="partsChart"></canvas></div>
      </div>

    </div>
  </section>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
  /* UUIDs — MUST match firmware (unchanged) */
  const OTA_SVC_UUID       = '12345678-1234-5678-1234-56789abcdef0';
  const INFO_STATS_UUID    = 'b8a7a0e2-1a5d-4c1e-9d93-2c9e2b9e1001';
  const INFO_SETTINGS_UUID = 'b8a7a0e2-1a5d-4c1e-9d93-2c9e2b9e1002';
  const INFO_CTRL_UUID     = 'b8a7a0e2-1a5d-4c1e-9d93-2c9e2b9e10ff';
  const INFO_PARTS_UUID    = 'b8a7a0e2-1a5d-4c1e-9d93-2c9e2b9e1003';

  // Control opcodes
  const OP_SET_PREF  = 0x50;
  const OP_SET_STAT  = 0x53;
  const OP_REST_DONE = 0x55;
  const OP_REST_BEGIN= 0x54;

  let device, server, service, chStats, chSettings, chCtrl, chParts;

  function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

  async function withRetry(fn, {tries=5, base=120} = {}) {
    let err;
    for (let i=0;i<tries;i++){
      try { return await fn(); }
      catch(e){ err = e; await sleep(base * Math.pow(1.6, i)); }
    }
    throw err;
  }

  async function readWithRetry(ch, tries=5){
    return withRetry(() => ch.readValue(), { tries, base: 150 });
  }

  /* i18n (complete) */
  const i18n = {
    en: {
      title: "Smart Rosary — Dashboard",
      connect: "Connect", refresh: "Refresh", reset: "Reset Statistics", disconnect: "Disconnect",
      backup: "Download", restore: "Restore",
      statusNot: "Not connected.",
      overview: "Overview",
      beads: "Beads", decades: "Decades", rosaries: "Rosaries", chaplets: "Chaplets",
      averages: "Durations & Averages",
      avgBead: "Avg bead", avgDecade: "Avg decade", avgRosary: "Avg rosary", avgChaplet: "Avg chaplet",
      avgNote: "Averages are computed from lifetime device totals.",
      barTitle: "Average durations (s)",
      donutTitle: "Mystery Sets Breakdown",
      partsTitle: "Mystery Parts (I–V per set)",
      device: "Device", firmware: "FW", lastMystery: "Last mystery",
      chartBead: "Bead", chartDecade: "Decade", chartRosary: "Rosary", chartChaplet: "Chaplet",
      sets: ["None","Joyful","Sorrowful","Glorious","Luminous","Chaplet"],
      errPick: "Picked device is not a rosary.",
      errWB: "Web Bluetooth not supported in this browser.",
      confirmReset: "Reset all statistics on the device? This cannot be undone.",
      statusConnected: "Connected. Reading…",
      statusUpdated: "Up to date.",
      statusResetReq: "Statistics reset requested…",
      statusDisconnected: "Disconnected.",
      bkTip: "",
      backupStart: (n)=>`Creating backup…`,
      backupDone:  "Backup ready.",
      restoreStart:"Restoring…",
      restoreDone: "Restore complete.",
      totalsTitle: "Totals (time)",
      totBeads: "Beads",
      totDecades: "Decades",
      totRosary: "Rosary",
      totChaplet: "Chaplet",
      pillDevice: "Device",
      pillFW: "FW",
      pillLastMystery: "Last mystery",
      sets: ["None","Joyful","Sorrowful","Glorious","Luminous","Chaplet"],
    },
    pl: {
      title: "Smart Rosary — Panel",
      connect: "Połącz", refresh: "Odśwież", reset: "Wyzeruj statystyki", disconnect: "Rozłącz",
      backup: "Pobierz", restore: "Przywróć",
      statusNot: "Brak połączenia.",
      overview: "Przegląd",
      beads: "Pacierze", decades: "Dziesiątki", rosaries: "Różańce", chaplets: "Koronki",
      averages: "Czasy i średnie",
      avgBead: "Śr. paciorek", avgDecade: "Śr. dziesiątek", avgRosary: "Śr. różaniec", avgChaplet: "Śr. koronka",
      avgNote: "Średnie liczone z sum od początku.",
      barTitle: "Średnie czasy (s)",
      donutTitle: "Podział tajemnic",
      partsTitle: "Tajemnice — części (I–V)",
      device: "Urządzenie", firmware: "FW", lastMystery: "Ostatnia tajemnica",
      chartBead: "Pac.", chartDecade: "Dzies.", chartRosary: "Róż.", chartChaplet: "Kor.",
      sets: ["Brak","Radosne","Bolesne","Chwalebne","Światła","Chaplet"],
      errPick: "Wybrane urządzenie to nie różaniec.",
      errWB: "Przeglądarka nie obsługuje Web Bluetooth.",
      confirmReset: "Zresetować wszystkie statystyki na urządzeniu? Tej operacji nie można cofnąć.",
      statusConnected: "Połączono. Wczytywanie…",
      statusUpdated: "Aktualne.",
      statusResetReq: "Żądanie resetu statystyk…",
      statusDisconnected: "Rozłączono.",
      bkTip: "",
      backupStart: (n)=>`Tworzenie kopii…`,
      backupDone:  "Kopia gotowa.",
      restoreStart:"Przywracanie…",
      restoreDone: "Przywrócono.",
      totalsTitle: "Suma (czas)",
      totBeads: "Pacierze",
      totDecades: "Dziesiątki",
      totRosary: "Różaniec",
      totChaplet: "Koronka",
      pillDevice: "Urządzenie",
      pillFW: "FW",
      pillLastMystery: "Ostatnia tajemnica",
      sets: ["Brak","Radosne","Bolesne","Chwalebne","Światła","Koronka"],
    },
    de: {
      title: "Smart Rosary — Dashboard",
      connect: "Verbinden", refresh: "Aktualisieren", reset: "Statistiken zurücksetzen", disconnect: "Trennen",
      backup: "Herunterladen", restore: "Wiederherstellen",
      statusNot: "Nicht verbunden.",
      overview: "Übersicht",
      beads: "Perlen", decades: "Gesätzchen", rosaries: "Rosenkränze", chaplets: "Koronen",
      averages: "Dauern & Durchschnitte",
      avgBead: "Ø Perle", avgDecade: "Ø Gesätzchen", avgRosary: "Ø Rosenkranz", avgChaplet: "Ø Korone",
      avgNote: "Durchschnitte über die gesamte Laufzeit.",
      barTitle: "Durchschnittsdauern (s)",
      donutTitle: "Aufschlüsselung der Geheimnisse",
      partsTitle: "Geheimnisse — Teile (I–V)",
      device: "Gerät", firmware: "FW", lastMystery: "Letztes Geheimnis",
      chartBead: "Perle", chartDecade: "Gesätzchen", chartRosary: "Rosenkranz", chartChaplet: "Korone",
      sets: ["Keins","Freudenreiche","Schmerzensreiche","Glorreiche","Lichtreiche","Koronen"],
      errPick: "Ausgewähltes Gerät ist kein Rosary.",
      errWB: "Web Bluetooth wird von diesem Browser nicht unterstützt.",
      confirmReset: "Alle Statistiken auf dem Gerät zurücksetzen? Dies kann nicht rückgängig gemacht werden.",
      statusConnected: "Verbunden. Lese…",
      statusUpdated: "Aktuell.",
      statusResetReq: "Zurücksetzen angefordert…",
      statusDisconnected: "Getrennt.",
      bkTip: "",
      backupStart: (n)=>`Backup wird erstellt…`,
      backupDone:  "Backup bereit.",
      restoreStart:"Wiederherstellen…",
      restoreDone: "Wiederherstellung abgeschlossen.",
      totalsTitle: "Summen (Zeit)",
      totBeads: "Perlen",
      totDecades: "Gesätzchen",
      totRosary: "Rosenkranz",
      totChaplet: "Korone",
      pillDevice: "Gerät",
      pillFW: "FW",
      pillLastMystery: "Letztes Geheimnis",
      sets: ["Keins","Freudenreiche","Schmerzensreiche","Glorreiche","Lichtreiche","Barmherzigkeitsrosenkranz"],
    }
  };

  const $ = id => document.getElementById(id);
  let lang = 'en';
  const statusLine = $('status');

  function fmtMs(ms){
    if (ms == null || isNaN(ms)) return '—';
    ms = Math.max(0, Math.round(ms));
    if (ms < 1000) return `${ms} ms`;
    let s = Math.floor(ms/1000);
    if (s < 60) return `${s}s`;
    let m = Math.floor(s/60); s = s % 60;
    if (m < 60) return `${m}m ${s}s`;
    let h = Math.floor(m/60); m = m % 60;
    return `${h}h ${m}m ${s}s`;
  }

    let lastStats = null;
    let lastSettings = null;

    function localizeSetName(enName, langCode = lang){
      const idxMap = { None:0, Joyful:1, Sorrowful:2, Glorious:3, Luminous:4, Chaplet:5 };
      const idx = idxMap[enName];
      if (idx == null) return enName;
      const L = i18n[langCode] || i18n.en;
      return L.sets[idx] || enName;
    }

    function renderPillsFromCache(){
      if (!lastStats || !lastSettings) return;
      const L = i18n[lang];

      $('pillDevice').textContent = `${L.device}: ${lastStats.device || '—'}`;
      $('pillFW').textContent     = `${L.firmware}: ${lastSettings.fwVersion || '—'}`;

      const lastSetEN  = lastStats.lastMystery?.set;
      const lastIndex  = lastStats.lastMystery?.index;
      const lastSetLOC = lastSetEN ? localizeSetName(lastSetEN) : '—';
      $('pillLastMystery').textContent =
        `${L.lastMystery}: ${lastSetLOC}${lastIndex ? ` #${lastIndex}` : ''}`;
    }

  function applyI18n() {
    const L = i18n[lang];
    $('titleTxt').textContent   = L.title;
    $('connectBtn').textContent = L.connect;
    $('refreshBtn').textContent = L.refresh;
    $('resetBtn').textContent   = L.reset;
    $('disconnectBtn').textContent = L.disconnect;
    $('backupBtn').textContent  = L.backup;
    $('restoreBtn').textContent = L.restore;
    statusLine.textContent = L.statusNot;

    $('overviewTitle').textContent = L.overview;
    $('lblBeads').textContent   = L.beads;
    $('lblDecades').textContent = L.decades;
    $('lblRosaries').textContent= L.rosaries;
    $('lblChaplets').textContent= L.chaplets;

    $('avgTitle').textContent = L.averages;
    $('lblAvgBead').textContent    = L.avgBead;
    $('lblAvgDecade').textContent  = L.avgDecade;
    $('lblAvgRosary').textContent  = L.avgRosary;
    $('lblAvgChaplet').textContent = L.avgChaplet;
    $('avgNote').textContent       = L.avgNote;

    $('barTitle').textContent   = L.barTitle;
    $('donutTitle').textContent = L.donutTitle;
    $('partsTitle').textContent = L.partsTitle;
    $('bkNote').textContent     = L.bkTip;

    $('totalsTitle').textContent = L.totalsTitle;
    $('lblTbeads').textContent   = L.totBeads;
    $('lblTdecades').textContent = L.totDecades;
    $('lblTrosary').textContent  = L.totRosary;
    $('lblTchaplet').textContent = L.totChaplet;

    $('lblDevice').textContent      = L.pillDevice;
    $('lblFW').textContent          = L.pillFW;
    $('lblLastMystery').textContent = L.pillLastMystery;

    // Update chart labels (now 4 including Chaplet)
    barWindow.data.labels = [L.chartBead, L.chartDecade, L.chartRosary, L.chartChaplet];
    barWindow.update();

    donutSets.data.labels = L.sets.slice();
    donutSets.update();

    partsChart.data.labels = [L.sets[0], L.sets[1], L.sets[4], L.sets[2], L.sets[3]];
    partsChart.update();

    renderPillsFromCache();
  }

  function u8ToStr(v){ return new TextDecoder().decode(v); }
  function safeNum(x, d=0){ const v = Number(x); return isFinite(v) ? v : d; }

  /* Charts */
  const barWindow = new Chart($('barWindow').getContext('2d'), {
    type: 'bar',
    data: {
      labels: ['Bead','Decade','Rosary','Chaplet'],
      datasets: [{
        label: 'Avg (s)',
        data: [0, 0, 0, 0],
        // Make chaplet visibly brown
        backgroundColor: ['#9fb3c8','#9fb3c8','#9fb3c8','#8b5a2b']
      }]
    },
    options: {
      responsive:true, maintainAspectRatio:false,
      scales:{ y:{ beginAtZero:true, ticks:{ precision:0 }, grid:{ color:'#1a2733' } }, x:{ grid:{ color:'#1a2733' } } },
      plugins:{ legend:{ display:false } }
    }
  });

  const donutSets = new Chart($('donutSets').getContext('2d'), {
    type: 'doughnut',
    data: {
      labels: ['None','Joyful','Sorrowful','Glorious','Luminous','Chaplet'],
      datasets: [{
        data: [0, 0, 0, 0, 0, 0],
        backgroundColor: [
          '#808080', // None
          '#ffcc00', // Joyful
          '#cc0000', // Sorrowful
          '#00cc00', // Glorious
          '#3399ff', // Luminous
          '#8B4513'  // Chaplet (brown)
        ],
        borderColor: '#0b0f14',
        borderWidth: 2
      }]
    },
    options: {
      responsive:true,
      maintainAspectRatio:false,
      plugins:{ legend:{ position:'bottom', labels:{ color:'#eaf0f6' } } },
      cutout:'60%'
    }
  });

  const partsCtx = $('partsChart').getContext('2d');
  const partShades = {
    none:      ['#9e9e9e','#8f8f8f','#808080','#717171','#626262'],
    joyful:    ['#ffe680','#ffdb4d','#ffcc00','#e6b800','#cc9a00'],
    sorrowful: ['#ff6666','#ff3333','#cc0000','#990000','#730000'],
    glorious:  ['#66ff66','#33e633','#00cc00','#00a300','#007a00'],
    luminous:  ['#99ccff','#66b2ff','#3399ff','#1a7fd6','#0066cc'],
  };
  const partsChart = new Chart(partsCtx, {
    type: 'bar',
    data: {
      labels: ['None','Joyful','Luminous','Sorrowful','Glorious'],
      datasets: [
        { label: 'I',  data: [0,0,0,0,0], backgroundColor: [partShades.none[0],partShades.joyful[0],partShades.luminous[0],partShades.sorrowful[0],partShades.glorious[0]] },
        { label: 'II', data: [0,0,0,0,0], backgroundColor: [partShades.none[1],partShades.joyful[1],partShades.luminous[1],partShades.sorrowful[1],partShades.glorious[1]] },
        { label: 'III',data: [0,0,0,0,0], backgroundColor: [partShades.none[2],partShades.joyful[2],partShades.luminous[2],partShades.sorrowful[2],partShades.glorious[2]] },
        { label: 'IV', data: [0,0,0,0,0], backgroundColor: [partShades.none[3],partShades.joyful[3],partShades.luminous[3],partShades.sorrowful[3],partShades.glorious[3]] },
        { label: 'V',  data: [0,0,0,0,0], backgroundColor: [partShades.none[4],partShades.joyful[4],partShades.luminous[4],partShades.sorrowful[4],partShades.glorious[4]] },
      ]
    },
    options: {
      responsive:true, maintainAspectRatio:false,
      plugins:{ legend:{ position:'bottom', labels:{ color:'#eaf0f6' } } },
      scales:{
        x:{ stacked:true, grid:{ color:'#1a2733' }, ticks:{ color:'#cfe4ff' } },
        y:{ stacked:true, beginAtZero:true, grid:{ color:'#1a2733' }, ticks:{ color:'#cfe4ff', precision:0 } }
      }
    }
  });

async function connectBLE(){
  const L = i18n[lang];
  try{
    if (!navigator.bluetooth) throw new Error(L.errWB);
    statusLine.textContent = 'Requesting device…';

    let dev;
    try {
      dev = await navigator.bluetooth.requestDevice({
        filters: [{ services: [OTA_SVC_UUID] }],
        optionalServices: [OTA_SVC_UUID]
      });
    } catch {
      dev = await navigator.bluetooth.requestDevice({
        acceptAllDevices: true,
        optionalServices: [OTA_SVC_UUID]
      });
      if (!dev.name || !dev.name.toLowerCase().startsWith('rosary')) {
        throw new Error(L.errPick);
      }
    }

    device = dev;
    device.addEventListener('gattserverdisconnected', onDisconnected);

    statusLine.textContent = 'Connecting…';
    server  = await device.gatt.connect();

    // 🔧 Android quirk: give the GATT a moment to finish service discovery.
    await sleep(300);

    // Get service/characteristics with retries (Android sometimes races here)
    service   = await withRetry(() => server.getPrimaryService(OTA_SVC_UUID));
    chSettings= await withRetry(() => service.getCharacteristic(INFO_SETTINGS_UUID));
    chParts   = await withRetry(() => service.getCharacteristic(INFO_PARTS_UUID));
    chStats   = await withRetry(() => service.getCharacteristic(INFO_STATS_UUID));
    chCtrl    = await withRetry(() => service.getCharacteristic(INFO_CTRL_UUID));

    $('refreshBtn').disabled = false;
    $('resetBtn').disabled   = false;
    $('backupBtn').disabled  = false;
    $('restoreBtn').disabled = false;
    $('disconnectBtn').disabled = true;

    statusLine.textContent = L.statusConnected;

    // First reads with retry (smaller ones first)
    await withRetry(refresh);

    $('disconnectBtn').disabled = false;
  } catch(err){
    console.error(err);
    statusLine.textContent = 'Error: ' + err.message;
  }
}

async function refresh(){
  const L = i18n[lang];
  try{
    if (!chStats || !chSettings) return;

    // Android quirk: give discovery/MTU a moment before first reads
    await sleep(200);

    // Read small blobs first (settings, parts), then the big stats blob last.
    const [vSettings, vPartsMaybe] = await Promise.all([
      readWithRetry(chSettings),
      chParts ? readWithRetry(chParts).catch(()=>null) : Promise.resolve(null)
    ]);

    // Stats is usually the largest – do it after a tiny pause and with retry.
    await sleep(80);
    const vStats = await readWithRetry(chStats);

    const jsStats    = JSON.parse(u8ToStr(vStats));
    const jsSettings = JSON.parse(u8ToStr(vSettings));

    // cache for later re-localization without BLE reads
    lastStats = jsStats;
    lastSettings = jsSettings;

    $('kpiBeads').textContent    = (jsStats.totals?.beads ?? '—');
    $('kpiDecades').textContent  = (jsStats.totals?.decades ?? '—');
    $('kpiRosaries').textContent = (jsStats.totals?.rosaries ?? '—');
    $('kpiChaplets').textContent = (jsStats.totals?.chaplets ?? '—');

    const Ldev = i18n[lang];
    $('pillDevice').textContent = `${Ldev.device}: ${jsStats.device || '—'}`;
    $('pillFW').textContent     = `${Ldev.firmware}: ${jsSettings.fwVersion || '—'}`;
    const lastSetEN  = jsStats.lastMystery?.set;   // e.g., "Luminous"
    const lastIndex  = jsStats.lastMystery?.index; // 1..5 (or 0)
    const lastSetLOC = lastSetEN ? localizeSetName(lastSetEN) : '—';
    $('pillLastMystery').textContent =
      `${Ldev.lastMystery}: ${lastSetLOC}${lastIndex ? ` #${lastIndex}` : ''}`;

    // Durations
    const d = jsStats.durations || {};
    const avgBeadMs     = safeNum(d.avgBeadMs,     0);
    const avgDecadeMs   = safeNum(d.avgDecadeMs,   0);
    const avgRosaryMs   = safeNum(d.avgRosaryMs,   0);
    const avgChapletMs  = safeNum(d.avgChapletMs,  0);
    const totBeadMs     = safeNum(d.totalBeadMs,     0);
    const totDecadeMs   = safeNum(d.totalDecadeMs,   0);
    const totRosaryMs   = safeNum(d.totalRosaryMs,   0);
    const totChapletMs  = safeNum(d.totalChapletMs,  0);

    $('kpiAvgBead').textContent     = fmtMs(avgBeadMs);
    $('kpiAvgDecade').textContent   = fmtMs(avgDecadeMs);
    $('kpiAvgRosary').textContent   = fmtMs(avgRosaryMs);
    $('kpiAvgChaplet').textContent  = fmtMs(avgChapletMs);

    $('totRosary').textContent  = fmtMs(totRosaryMs);
    $('totDecade').textContent  = fmtMs(totDecadeMs);
    $('totBead').textContent    = fmtMs(totBeadMs);
    $('totChaplet').textContent = fmtMs(totChapletMs);

    barWindow.data.datasets[0].data = [
      avgBeadMs/1000,
      avgDecadeMs/1000,
      avgRosaryMs/1000,
      avgChapletMs/1000
    ];
    barWindow.update();

    // Sets (unchanged — chaplet is not a mystery set)
    const totalDec = (jsStats.totals?.decades ?? 0);
    const joyful   = (jsStats.sets?.joyful ?? 0);
    const sorrow   = (jsStats.sets?.sorrowful ?? 0);
    const glor     = (jsStats.sets?.glorious ?? 0);
    const lumi     = (jsStats.sets?.luminous ?? 0);
    const chap = (jsStats.totals?.chaplets ?? 0);
    let none       = jsStats.sets?.none;
    if (none == null) {
      const sumKnown = joyful + sorrow + glor + lumi;
      none = Math.max(0, totalDec - sumKnown);
    }
    donutSets.data.datasets[0].data = [none, joyful, sorrow, glor, lumi, chap];
    donutSets.update();

    // Parts (optional char; tolerate failures)
    if (vPartsMaybe) {
      try {
        const jsParts = JSON.parse(u8ToStr(vPartsMaybe));
        const sp = jsParts.setsParts || {};
        const setsOrder = ['none','joyful','luminous','sorrowful','glorious']; // UI order
        const dataByPart = [0,1,2,3,4].map(()=>[0,0,0,0,0]);

        setsOrder.forEach((name, si) => {
          const arr = sp[name] || [0,0,0,0,0];
          for (let p=0;p<5;p++) dataByPart[p][si] = Number(arr[p]||0);
        });
        for (let p=0;p<5;p++) partsChart.data.datasets[p].data = dataByPart[p];
        partsChart.update();
      } catch(e) {
        console.warn('Parts parse/read failed:', e);
      }
    }

    statusLine.textContent = L.statusUpdated;
    renderPillsFromCache();
  } catch(err){
    console.error(err);
    statusLine.textContent = 'Read failed: ' + err.message;
  }
}

  async function resetStats(){
    const L = i18n[lang];
    try{
      if (!chCtrl) return;
      if (!confirm(L.confirmReset)) return;
      await chCtrl.writeValue(new Uint8Array([0x01]));
      setTimeout(refresh, 300);
      statusLine.textContent = L.statusResetReq;
    } catch(err){
      console.error(err);
      statusLine.textContent = 'Reset failed: ' + err.message;
    }
  }

  function onDisconnected(){
    const L = i18n[lang];
    statusLine.textContent = L.statusDisconnected;
    $('refreshBtn').disabled = true;
    $('resetBtn').disabled   = true;
    $('disconnectBtn').disabled = true;
    $('backupBtn').disabled  = true;
    $('restoreBtn').disabled = true;
  }

  async function disconnectBLE(){
    try { if (device && device.gatt.connected) await device.gatt.disconnect(); }
    catch (e) { console.warn(e); }
    finally { onDisconnected(); }
  }
  

  // --- helpers for flaky Android GATT reads ---
async function reacquireChars() {
  // Re-fetch service & characteristics from the current server
  service    = await withRetry(() => server.getPrimaryService(OTA_SVC_UUID));
  chSettings = await withRetry(() => service.getCharacteristic(INFO_SETTINGS_UUID));
  // parts is optional
  try { chParts = await withRetry(() => service.getCharacteristic(INFO_PARTS_UUID)); }
  catch { chParts = null; }
  chStats    = await withRetry(() => service.getCharacteristic(INFO_STATS_UUID));
  chCtrl     = await withRetry(() => service.getCharacteristic(INFO_CTRL_UUID));
}

async function robustRead(ch) {
  // Try a normal read
  try { return await readWithRetry(ch); }
  catch (e1) {
    console.warn('read failed once, reacquiring chars…', e1);
    // Reacquire handles (Android sometimes invalidates them)
    await sleep(200);
    await reacquireChars();
    try { return await readWithRetry(ch); }
    catch (e2) {
      console.warn('read failed after reacquire, reconnecting…', e2);
      // Full reconnect, then reacquire and retry once more
      try { if (device?.gatt?.connected) device.gatt.disconnect(); } catch {}
      await sleep(250);
      server = await device.gatt.connect();
      await sleep(300);
      await reacquireChars();
      return await readWithRetry(ch);
    }
  }
}

// ---- Backup (Android friendly: paced reads + reacquire/reconnect fallback) ----
async function doBackup(){
  const L = i18n[lang];
  try{
    if (!chStats || !chSettings) return;
    statusLine.textContent = L.backupStart();

    // small settle
    await sleep(150);

    // Read smaller blobs first, then the larger stats (each via robustRead)
    const vSettings = await robustRead(chSettings);

    let vParts = null;
    if (chParts) {
      try { vParts = await robustRead(chParts); }
      catch (e) { console.warn('parts read skipped:', e); }
    }

    await sleep(80);
    const vStats = await robustRead(chStats);

    const jsStats    = JSON.parse(u8ToStr(vStats));
    const jsSettings = JSON.parse(u8ToStr(vSettings));

    // Ensure duration counters exist for reliable restore of averages
    const d = jsStats?.durations || {};
    const beadSum = Number(d.totalBeadMs ?? 0);
    const decSum  = Number(d.totalDecadeMs ?? 0);
    const rosSum  = Number(d.totalRosaryMs ?? 0);
    const chapSum = Number(d.totalChapletMs ?? 0);

    let beadCnt = Number(d.beadIntervals || 0);
    let decCnt  = Number(d.decadeCount   || 0);
    let rosCnt  = Number(d.rosaryCount   || 0);
    let chapCnt = Number(jsStats.totals?.chaplets ?? d.chapletCount ?? 0);

    if (!beadCnt) {
      const avg = Number(d.avgBeadMs || 0);
      beadCnt = avg > 0 ? Math.floor(beadSum / avg) : 0;
    }
    if (!decCnt) {
      const avg = Number(d.avgDecadeMs || 0);
      decCnt = avg > 0 ? Math.floor(decSum / avg) : 0;
    }
    if (!rosCnt) {
      const avg = Number(d.avgRosaryMs || 0);
      rosCnt = avg > 0 ? Math.floor(rosSum / avg) : 0;
    }
    if (!chapCnt) {
      const avg = Number(d.avgChapletMs || 0);
      chapCnt = avg > 0 ? Math.floor(chapSum / avg) : 0;
    }


    jsStats.durations = {
      ...d,
      beadIntervals: beadCnt,
      decadeCount:   decCnt,
      rosaryCount:   rosCnt,
      chapletCount:  chapCnt,
      totalBeadMs:   String(beadSum),
      totalDecadeMs: String(decSum),
      totalRosaryMs: String(rosSum),
      totalChapletMs:  String(chapSum)
      // chaplet fields (if your firmware emits them) will be kept as-is
    };

    const js = {
      device:    jsStats.device || '',
      fwVersion: jsSettings.fwVersion || '',
      stats:     jsStats,
      settings:  jsSettings,
      setsParts: null
    };

    if (vParts) {
      try {
        const jp = JSON.parse(u8ToStr(vParts));
        js.setsParts = jp.setsParts || null;
      } catch(e) {
        console.warn('Parts JSON parse skipped:', e);
      }
    }

    const blob = new Blob([JSON.stringify(js, null, 2)], { type: 'application/json' });
    const url  = URL.createObjectURL(blob);
    const a    = document.createElement('a');
    a.href = url;
    a.download = (js.device || 'rosary') + '_backup.json';
    a.click();
    URL.revokeObjectURL(url);

    statusLine.textContent = L.backupDone;
  } catch(err){
    console.error(err);
    statusLine.textContent = 'Backup failed: ' + err.message;
  }
}

  // ---- Restore (upload JSON -> many small SET_* writes) ----
  function le16(n){ const a=new Uint8Array(2); n=Number(n)>>>0; a[0]=n&255; a[1]=(n>>8)&255; return a; }
  function le32(n){ const a=new Uint8Array(4); n = Number(n)>>>0; a[0]=n&255; a[1]=(n>>8)&255; a[2]=(n>>16)&255; a[3]=(n>>24)&255; return a; }
  function le64Big(n){ const a = new Uint8Array(8); let x = BigInt(n); for (let i=0;i<8;i++){ a[i] = Number(x & 0xffn); x >>= 8n; } return a; }
  function packKV(op, type, key, valBytes){
    const k = new TextEncoder().encode(key);
    const out = new Uint8Array(1 + 1 + 1 + k.length + valBytes.length);
    out[0]=op; out[1]=type; out[2]=k.length; out.set(k,3); out.set(valBytes, 3+k.length);
    return out;
  }
  function encSize(type, value){
    switch (type){
      case 0x01: return 1; case 0x11: return 1; case 0x12: return 2; case 0x14: return 4; case 0x21: return 4; case 0x18: return 8;
      case 0x31: return new TextEncoder().encode(String(value)).length; default: throw new Error('bad type');
    }
  }

  async function writePrefKey(key, type, value){
    let valBytes;
    switch (type){
      case 0x01: valBytes = new Uint8Array([value?1:0]); break;
      case 0x11: valBytes = new Uint8Array([Number(value) & 0xff]); break;
      case 0x12: { const v=Number(value)>>>0; valBytes = new Uint8Array([v & 0xff, (v>>8)&0xff]); } break;
      case 0x14: valBytes = le32(value); break;
      case 0x21: valBytes = le32(value); break;
      case 0x18: valBytes = le64Big(BigInt(value)); break;
      case 0x31: valBytes = new TextEncoder().encode(String(value)); break;
      default: throw new Error('bad type');
    }
    const payload = packKV(OP_SET_PREF, type, key, valBytes);
    await chCtrl.writeValue(payload);
  }
  async function writeStatKey(key, type, value){
    let valBytes;
    switch (type){
      case 0x11: valBytes = new Uint8Array([Number(value) & 0xff]); break;
      case 0x12: { const v=Number(value)>>>0; valBytes = new Uint8Array([v & 0xff, (v>>8)&0xff]); } break;
      case 0x14: valBytes = le32(value); break;
      case 0x18: valBytes = le64Big(BigInt(value)); break;
      default: throw new Error('bad type');
    }
    const payload = packKV(OP_SET_STAT, type, key, valBytes);
    await chCtrl.writeValue(payload);
  }

  async function restoreFromJson(js, onProgress){
  // prefs mapping per Settings::load()
  const prefs = js.settings || js.prefs || {};
  const stAll = js.stats || {};

  // ----- cache once, no redeclarations later -----
  const totalsObj = stAll.totals || {};
  const lastObj   = stAll.lastMystery || {};
  const setsObj   = stAll.sets || {};
  const ringArr   = stAll.ring || [];
  const partsObj  = js.setsParts || stAll.setsParts || {};
  const durObj    = stAll.durations || {};

  // include Chaplet for completeness (even if device ignores it for “lastSet” legacy)
  const setMap = { None:0, Joyful:1, Luminous:2, Sorrowful:3, Glorious:4, Chaplet:5 };

  const order = ['none','joyful','luminous','sorrowful','glorious'];

  const totalSteps =
    13 + // prefs
    5 + 3 + 2 + 30 + 5 + (5*5) + 8; // <-- was 6
  let step=0;
  const tick = ()=>onProgress?.(++step, totalSteps);

  // ---- PREPASS: compute totalBytes for RESTORE_BEGIN ----
  let totalBytes = 0;
  const sumKV = (key, type, value) => { totalBytes += key.length + encSize(type, value); };

  // prefs booleans
  sumKV("haptic-en",     0x01, !!prefs.haptic);
  sumKV("m-preset-en",   0x01, !!(prefs.mystery?.preset));
  sumKV("m-autosave-en", 0x01, !!(prefs.mystery?.autosave));
  sumKV("m-intro-en",    0x01, !!(prefs.mystery?.intro));
  sumKV("i-en",          0x01, !!(prefs.intentions?.enabled));

  // prefs ints
  sumKV("disp-bright",   0x21, prefs.display?.brightness ?? 0);
  sumKV("disp-rot",      0x21, prefs.display?.rotation ?? 0);
  sumKV("wall-bright",   0x21, prefs.wallpaper?.brightness ?? 0);
  sumKV("ImageIndex",    0x21, prefs.wallpaper?.imageIndex ?? 0);
  sumKV("beadIndex",     0x21, prefs.mystery?.beadIndex ?? -1);
  sumKV("m-pos",         0x21, prefs.mystery?.pos ?? 0);
  sumKV("m-part",        0x21, prefs.mystery?.part ?? 0);
  sumKV("i-pos",         0x21, prefs.intentions?.pos ?? 0);

  // stats scalars
  sumKV("beads",    0x14, totalsObj.beads    ?? 0);
  sumKV("paters",   0x14, totalsObj.paters   ?? 0);
  sumKV("glorias",  0x14, totalsObj.glorias  ?? 0);
  sumKV("decades",  0x14, totalsObj.decades  ?? 0);
  sumKV("rosaries", 0x14, totalsObj.rosaries ?? 0);

  // last mystery + ts
  sumKV("lastSet", 0x11, setMap[lastObj.set] ?? 0);
  sumKV("lastIdx", 0x11, lastObj.index ?? 0);
  sumKV("lastTs",  0x14, stAll.lastPrayer ?? 0);

  // streak + baseDay
  sumKV("streak",  0x12, stAll.streakDays ?? 0);
  sumKV("baseDay", 0x14, 0);

  // ring[30]
  for (let i=0;i<30;i++){
    const key = `r${String(i).padStart(2,'0')}`;
    sumKV(key, 0x12, ringArr[i] ?? 0);
  }

  // sets totals set0..set4
  for (let si=0; si<5; si++){
    sumKV(`set${si}`, 0x14, setsObj[order[si]] ?? 0);
  }

  // parts pXY
  for (let si=0; si<5; si++){
    const arr = partsObj[order[si]] || [0,0,0,0,0];
    for (let pi=0; pi<5; pi++){
      sumKV(`p${si}${pi}`, 0x14, arr[pi] ?? 0);
    }
  }

  // durations: sums+counts
  sumKV("bSum", 0x18, BigInt(durObj.totalBeadMs   ?? 0));
  sumKV("bInt", 0x14, (durObj.beadIntervals ?? 0));
  sumKV("dSum", 0x18, BigInt(durObj.totalDecadeMs ?? 0));
  sumKV("dCnt", 0x14, (durObj.decadeCount  ?? 0));
  sumKV("rSum", 0x18, BigInt(durObj.totalRosaryMs ?? 0));
  sumKV("rCnt", 0x14, (durObj.rosaryCount  ?? 0));
  // NEW — Chaplet:
  sumKV("cSum", 0x18, BigInt(durObj.totalChapletMs ?? 0));
  sumKV("cCnt", 0x14, (stAll.totals?.chaplets ?? durObj.chapletCount ?? 0));

  // Send RESTORE_BEGIN so ESP32 can display progress based on bytes
  const begin = new Uint8Array(1+2+4);
  begin[0] = OP_REST_BEGIN;
  begin.set(le16(totalSteps), 1);
  begin.set(le32(totalBytes), 3);
  await chCtrl.writeValue(begin);

  // ---- ACTUAL WRITES ----

  // prefs booleans
  await writePrefKey("haptic-en",     0x01, !!prefs.haptic);                     tick();
  await writePrefKey("m-preset-en",   0x01, !!(prefs.mystery?.preset));          tick();
  await writePrefKey("m-autosave-en", 0x01, !!(prefs.mystery?.autosave));        tick();
  await writePrefKey("m-intro-en",    0x01, !!(prefs.mystery?.intro));           tick();
  await writePrefKey("i-en",          0x01, !!(prefs.intentions?.enabled));      tick();

  // prefs ints
  await writePrefKey("disp-bright",   0x21, prefs.display?.brightness ?? 0);     tick();
  await writePrefKey("disp-rot",      0x21, prefs.display?.rotation ?? 0);       tick();
  await writePrefKey("wall-bright",   0x21, prefs.wallpaper?.brightness ?? 0);   tick();
  await writePrefKey("ImageIndex",    0x21, prefs.wallpaper?.imageIndex ?? 0);   tick();
  await writePrefKey("beadIndex",     0x21, prefs.mystery?.beadIndex ?? -1);     tick();
  await writePrefKey("m-pos",         0x21, prefs.mystery?.pos ?? 0);            tick();
  await writePrefKey("m-part",        0x21, prefs.mystery?.part ?? 0);           tick();
  await writePrefKey("i-pos",         0x21, prefs.intentions?.pos ?? 0);         tick();

  // stats scalars
  await writeStatKey("beads",    0x14, totalsObj.beads    ?? 0); tick();
  await writeStatKey("paters",   0x14, totalsObj.paters   ?? 0); tick();
  await writeStatKey("glorias",  0x14, totalsObj.glorias  ?? 0); tick();
  await writeStatKey("decades",  0x14, totalsObj.decades  ?? 0); tick();
  await writeStatKey("rosaries", 0x14, totalsObj.rosaries ?? 0); tick();

  // last mystery + ts (legacy)
  await writeStatKey("lastSet", 0x11, setMap[lastObj.set] ?? 0);     tick();
  await writeStatKey("lastIdx", 0x11, lastObj.index ?? 0);           tick();
  await writeStatKey("lastTs",  0x14, stAll.lastPrayer ?? 0);        tick();

  // streak + baseDay
  await writeStatKey("streak",  0x12, stAll.streakDays ?? 0);        tick();
  await writeStatKey("baseDay", 0x14, 0);                            tick();

  // ring[30]
  for (let i=0;i<30;i++){
    const key = `r${String(i).padStart(2,'0')}`;
    await writeStatKey(key, 0x12, ringArr[i] ?? 0);                  tick();
  }

  // sets totals set0..set4
  for (let si=0; si<5; si++){
    await writeStatKey(`set${si}`, 0x14, setsObj[order[si]] ?? 0);   tick();
  }

  // parts pXY
  for (let si=0; si<5; si++){
    const arr = partsObj[order[si]] || [0,0,0,0,0];
    for (let pi=0; pi<5; pi++){
      await writeStatKey(`p${si}${pi}`, 0x14, arr[pi] ?? 0);         tick();
    }
  }

  // durations: sums+counts
  await writeStatKey("bSum", 0x18, BigInt(durObj.totalBeadMs   ?? 0)); tick();
  await writeStatKey("bInt", 0x14, (durObj.beadIntervals ?? 0));       tick();
  await writeStatKey("dSum", 0x18, BigInt(durObj.totalDecadeMs ?? 0)); tick();
  await writeStatKey("dCnt", 0x14, (durObj.decadeCount  ?? 0));        tick();
  await writeStatKey("rSum", 0x18, BigInt(durObj.totalRosaryMs ?? 0)); tick();
  await writeStatKey("rCnt", 0x14, (durObj.rosaryCount  ?? 0));        tick();
  // NEW — Chaplet:
  await writeStatKey("cSum", 0x18, BigInt(durObj.totalChapletMs ?? 0));                    tick();
  await writeStatKey("cCnt", 0x14, (stAll.totals?.chaplets ?? durObj.chapletCount ?? 0));  tick();

  // ask device to refresh JSON chars
  await chCtrl.writeValue(new Uint8Array([OP_REST_DONE]));
}

  // UI wiring
  $('connectBtn').addEventListener('click', connectBLE);
  $('refreshBtn').addEventListener('click', refresh);
  $('resetBtn').addEventListener('click', resetStats);
  $('disconnectBtn').addEventListener('click', disconnectBLE);
  $('backupBtn').addEventListener('click', doBackup);

  $('restoreBtn').addEventListener('click', () => $('restoreFile').click());
  $('restoreFile').addEventListener('change', async (e)=>{
    const f = e.target.files[0];
    if (!f) return;
    const L = i18n[lang];
    const prog = $('restoreProg'); prog.hidden = false; prog.value = 0;
    const text = await f.text();
    let js;
    try { js = JSON.parse(text); } catch { alert('Bad JSON'); prog.hidden=true; return; }
    statusLine.textContent = L.restoreStart;
    const onProg = (step,total)=>{ prog.value = Math.floor(step*100/total); };
    try{
      await restoreFromJson(js, onProg);
      await refresh();
      statusLine.textContent = L.restoreDone;
    } catch(err){
      console.error(err);
      statusLine.textContent = 'Restore failed: ' + err.message;
    } finally {
      setTimeout(()=>{ prog.hidden = true; }, 600);
      e.target.value = '';
    }
  });

  // Language selector
  $('langSelect').addEventListener('change', (ev)=>{ lang = ev.target.value; applyI18n(); });

  // Initial i18n
  applyI18n();
  </script>
</body>
</html>