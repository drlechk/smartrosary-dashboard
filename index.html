<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" type="image/svg+xml" href="favicon.svg">
<title>Smart Rosary â€” Dashboard</title>
<style>
  :root { color-scheme: dark; }
  * { box-sizing: border-box; }
  body {
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI",
                 Roboto, Ubuntu, "Helvetica Neue", Arial, sans-serif;
    margin:0; background:#0b0f14; color:#eaf0f6; overflow-x:hidden;
  }
  header {
    padding:18px 16px; text-align:center; border-bottom:1px solid #18212b; background:#0e141b;
  }
  h1 { margin:0; font-size:20px; font-weight:700; letter-spacing:.2px; }
  .toolbar-wrap { display:flex; justify-content:center; }
  .toolbar {
    display:flex; gap:8px; padding:12px; flex-wrap:wrap; align-items:center;
    width:100%; max-width: 980px;
  }
  button, select {
    border:0; border-radius:10px; padding:10px 14px; font-weight:600; cursor:pointer;
    transition:transform .05s ease; background:#1f2937; color:#eaf0f6;
  }
  button:active { transform:scale(0.98); }
  #connectBtn     { background:#03a9f4; color:#001018; }
  #refreshBtn     { background:#1f2937; }
  #backupBtn      { background:#0ea5e9; color:#001018; }
  #restoreBtn     { background:#16a34a; color:#00150b; }
  #disconnectBtn  { background:#b91c1c; color:#fff; }
  #resetBtn       { background:#9c27b0; color:#fff; }
  #langSelect     { background:#0f1720; border:1px solid #1f2b3a; }
  #status { text-align:center; color:#95a7ba; font-size:13px; padding-bottom:8px; }
  .wrap { max-width: 980px; margin: 0 auto; padding: 16px; }
  .grid { display:grid; gap:16px; grid-template-columns: repeat(2, minmax(280px, 1fr)); }
  @media (max-width: 800px) { .grid { grid-template-columns: 1fr; } }
  .card {
    background:#101722; border:1px solid #1a2733; border-radius:14px; padding:16px;
    box-shadow:0 6px 24px rgba(0,0,0,.25);
  }
  .card h3 { margin:0 0 12px; font-size:16px; font-weight:700; color:#cfe4ff; }
  .kpis { display:grid; grid-template-columns:repeat(2,1fr); gap:10px; }
  .kpi { background:#0d131c; border:1px solid #172231; border-radius:12px; padding:10px 12px; }
  .kpi .label { color:#9fb3c8; font-size:12px; }
  .kpi .value { font-size:18px; font-weight:800; margin-top:2px; line-height:1.1; }
  .pill {
    display:inline-block; background:#0d2030; border:1px solid #1d3551;
    color:#cde3ff; padding:6px 10px; border-radius:999px; font-size:13px;
  }
  .flex { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  .muted { color:#95a7ba; font-size:12px; }
  .smallnote { color:#7d8fa1; font-size:11px; margin-top:8px; }
  .chart { position:relative; width:100%; height:260px; }
  canvas { display:block; width:100%; height:100%; }

  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  #restoreProg {
    width:100%; height:10px; background:#0d131c; border:1px solid #172231; border-radius:999px; overflow:hidden;
    margin-top:8px;
  }
</style>
</head>
<body>
  <header>
    <h1 id="titleTxt">Smart Rosary â€” Dashboard</h1>
  </header>

  <div class="toolbar-wrap">
    <div class="toolbar">
      <button id="connectBtn">Connect</button>
      <button id="refreshBtn" disabled>Refresh</button>
      
      <div class="row"></div>

      <button id="resetBtn" disabled>Reset Statistics</button>
      <button id="disconnectBtn" disabled>Disconnect</button>
      <span style="flex:1"></span>
      <label for="langSelect" class="muted" style="font-weight:600;margin-right:6px;">Language</label>
      <select id="langSelect">
        <option value="en">English</option>
        <option value="pl">Polski</option>
        <option value="de">Deutsch</option>
      </select>
    </div>
  </div>

  <div id="status">Not connected.</div>

  <section class="wrap">
    <div class="grid">
      <div class="card">
        <h3 id="overviewTitle">Overview</h3>
        <div class="kpis" style="grid-template-columns:repeat(3,1fr);">
          <div class="kpi"><div class="label" id="lblBeads">Beads</div><div class="value" id="kpiBeads">â€”</div></div>
          <div class="kpi"><div class="label" id="lblDecades">Decades</div><div class="value" id="kpiDecades">â€”</div></div>
          <div class="kpi"><div class="label" id="lblRosaries">Rosaries</div><div class="value" id="kpiRosaries">â€”</div></div>
        </div>
        <div class="flex" style="margin-top:12px;">
          <span class="pill" id="pillDevice">Device: â€”</span>
          <span class="pill" id="pillFW">FW: â€”</span>
          <span class="pill" id="pillLastMystery">Last mystery: â€”</span>
        </div>
        <p class="smallnote" id="bkNote"></p>
      </div>

      <div class="card">
        <h3 id="avgTitle">Durations & Averages</h3>
         <div class="kpis" style="grid-template-columns:repeat(3,1fr);">
          <div class="kpi"><div class="label" id="lblAvgBead">Avg bead</div><div class="value" id="kpiAvgBead">â€”</div></div>
          <div class="kpi"><div class="label" id="lblAvgDecade">Avg decade</div><div class="value" id="kpiAvgDecade">â€”</div></div>
          <div class="kpi"><div class="label" id="lblAvgRosary">Avg rosary</div><div class="value" id="kpiAvgRosary">â€”</div></div>
        </div>
        <p class="smallnote" id="avgNote">Averages are computed from lifetime device totals.</p>
        <h3>Totals (time)</h3>
        <div class="kpis" style="grid-template-columns:repeat(3,1fr);">
          <div class="kpi"><div class="label">Rosary</div><div class="value" id="totRosary">â€”</div></div>
          <div class="kpi"><div class="label">Decades</div><div class="value" id="totDecade">â€”</div></div>
          <div class="kpi"><div class="label">Beads</div><div class="value" id="totBead">â€”</div></div>
        </div>
      </div>


      <div class="card">
        <h3 id="barTitle">Average durations (s)</h3>
        <div class="chart"><canvas id="barWindow"></canvas></div>
      </div>

      <div class="card">
        <h3 id="donutTitle">Mystery Sets Breakdown</h3>
        <div class="chart"><canvas id="donutSets"></canvas></div>
      </div>

      <div class="card">
        <h3 id="partsTitle">Mystery Parts (Iâ€“V per set)</h3>
        <div class="chart"><canvas id="partsChart"></canvas></div>
      </div>

      <!-- Backup & Restore in its own card -->
      <div class="card">
        <h3>Backup & Restore</h3>
        <div class="row">
          <button id="backupBtn"  disabled>Download Backup</button>
          <input type="file" id="restoreFile" accept="application/json" style="display:none">
          <button id="restoreBtn" disabled>Restore from Backupâ€¦</button>
          <progress id="restoreProg" max="100" value="0" hidden></progress>
        </div>
      </div>
    </div>
  </section>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
  /* UUIDs â€” MUST match firmware (unchanged) */
  const OTA_SVC_UUID       = '12345678-1234-5678-1234-56789abcdef0';
  const INFO_STATS_UUID    = 'b8a7a0e2-1a5d-4c1e-9d93-2c9e2b9e1001';
  const INFO_SETTINGS_UUID = 'b8a7a0e2-1a5d-4c1e-9d93-2c9e2b9e1002';
  const INFO_CTRL_UUID     = 'b8a7a0e2-1a5d-4c1e-9d93-2c9e2b9e10ff';
  const INFO_PARTS_UUID    = 'b8a7a0e2-1a5d-4c1e-9d93-2c9e2b9e1003';

  // Control opcodes
  const OP_SET_PREF  = 0x50;
  const OP_SET_STAT  = 0x53;
  const OP_REST_DONE = 0x55;
  const OP_REST_BEGIN= 0x54; // <-- added

  let device, server, service, chStats, chSettings, chCtrl, chParts;

  function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

  async function withRetry(fn, {tries=5, base=120} = {}) {
    let err;
    for (let i=0;i<tries;i++){
      try { return await fn(); }
      catch(e){ err = e; await sleep(base * Math.pow(1.6, i)); }
    }
    throw err;
  }

  async function readWithRetry(ch, tries=5){
    return withRetry(() => ch.readValue(), { tries, base: 150 });
  }

  /* i18n (complete) */
  const i18n = {
    en: {
      title: "Smart Rosary â€” Dashboard",
      connect: "Connect", refresh: "Refresh", reset: "Reset Statistics", disconnect: "Disconnect",
      backup: "Download Backup", restore: "Restore from Backupâ€¦",
      statusNot: "Not connected.",
      overview: "Overview",
      beads: "Beads", decades: "Decades", rosaries: "Rosaries", streak: "Streak (days)",
      averages: "Durations & Averages",
      avgBead: "Avg bead", avgDecade: "Avg decade", avgRosary: "Avg rosary",
      avgNote: "Averages are computed from lifetime device totals (no RTC).",
      barTitle: "Average durations (s)",
      donutTitle: "Mystery Sets Breakdown",
      partsTitle: "Mystery Parts (Iâ€“V per set)",
      device: "Device", firmware: "FW", lastMystery: "Last mystery",
      chartBead: "Bead", chartDecade: "Decade", chartRosary: "Rosary",
      sets: ["None","Joyful","Sorrowful","Glorious","Luminous"],
      errPick: "Picked device is not a rosary.",
      errWB: "Web Bluetooth not supported in this browser.",
      confirmReset: "Reset all statistics on the device? This cannot be undone.",
      statusConnected: "Connected. Readingâ€¦",
      statusUpdated: "Up to date.",
      statusResetReq: "Statistics reset requestedâ€¦",
      statusDisconnected: "Disconnected.",
      bkTip: "",
      backupStart: (n)=>`Creating backupâ€¦`,
      backupDone:  "Backup ready.",
      restoreStart:"Restoringâ€¦",
      restoreDone: "Restore complete."
    },
    pl: {
      title: "Smart Rosary â€” Panel",
      connect: "PoÅ‚Ä…cz", refresh: "OdÅ›wieÅ¼", reset: "Wyzeruj statystyki", disconnect: "RozÅ‚Ä…cz",
      backup: "Pobierz kopiÄ™", restore: "PrzywrÃ³Ä‡ z kopiiâ€¦",
      statusNot: "Brak poÅ‚Ä…czenia.",
      overview: "PrzeglÄ…d",
      beads: "Pacierze", decades: "DziesiÄ…tki", rosaries: "RÃ³Å¼aÅ„ce", streak: "Seria (dni)",
      averages: "Czasy i Å›rednie",
      avgBead: "Åšr. paciorek", avgDecade: "Åšr. dziesiÄ…tek", avgRosary: "Åšr. rÃ³Å¼aniec",
      avgNote: "Åšrednie liczone z sum od poczÄ…tku.",
      barTitle: "Åšrednie czasy (s)",
      donutTitle: "PodziaÅ‚ tajemnic",
      partsTitle: "Tajemnice â€” czÄ™Å›ci (Iâ€“V)",
      device: "UrzÄ…dzenie", firmware: "FW", lastMystery: "Ostatnia tajemnica",
      chartBead: "Pac.", chartDecade: "Dzies.", chartRosary: "RÃ³Å¼.",
      sets: ["Brak","Radosne","Bolesne","Chwalebne","ÅšwiatÅ‚a"],
      errPick: "Wybrane urzÄ…dzenie to nie rÃ³Å¼aniec.",
      errWB: "PrzeglÄ…darka nie obsÅ‚uguje Web Bluetooth.",
      confirmReset: "ZresetowaÄ‡ wszystkie statystyki na urzÄ…dzeniu? Tej operacji nie moÅ¼na cofnÄ…Ä‡.",
      statusConnected: "PoÅ‚Ä…czono. Wczytywanieâ€¦",
      statusUpdated: "Aktualne.",
      statusResetReq: "Å»Ä…danie resetu statystykâ€¦",
      statusDisconnected: "RozÅ‚Ä…czono.",
      bkTip: "",
      backupStart: (n)=>`Tworzenie kopiiâ€¦`,
      backupDone:  "Kopia gotowa.",
      restoreStart:"Przywracanieâ€¦",
      restoreDone: "PrzywrÃ³cono."
    },
    de: {
      title: "Smart Rosary â€” Dashboard",
      connect: "Verbinden", refresh: "Aktualisieren", reset: "Statistiken zurÃ¼cksetzen", disconnect: "Trennen",
      backup: "Backup herunterladen", restore: "Aus Backup wiederherstellenâ€¦",
      statusNot: "Nicht verbunden.",
      overview: "Ãœbersicht",
      beads: "Perlen", decades: "GesÃ¤tzchen", rosaries: "RosenkrÃ¤nze", streak: "Serie (Tage)",
      averages: "Dauern & Durchschnitte",
      avgBead: "Ã˜ Perle", avgDecade: "Ã˜ GesÃ¤tzchen", avgRosary: "Ã˜ Rosenkranz",
      avgNote: "Durchschnitte Ã¼ber die gesamte Laufzeit.",
      barTitle: "Durchschnittsdauern (s)",
      donutTitle: "AufschlÃ¼sselung der Geheimnisse",
      partsTitle: "Geheimnisse â€” Teile (Iâ€“V)",
      device: "GerÃ¤t", firmware: "FW", lastMystery: "Letztes Geheimnis",
      chartBead: "Perle", chartDecade: "GesÃ¤tzchen", chartRosary: "Rosenkranz",
      sets: ["Keins","Freudenreich","Schmerzensreich","Glorreiche","Lichtreiche"],
      errPick: "AusgewÃ¤hltes GerÃ¤t ist kein Rosary.",
      errWB: "Web Bluetooth wird von diesem Browser nicht unterstÃ¼tzt.",
      confirmReset: "Alle Statistiken auf dem GerÃ¤t zurÃ¼cksetzen? Dies kann nicht rÃ¼ckgÃ¤ngig gemacht werden.",
      statusConnected: "Verbunden. Leseâ€¦",
      statusUpdated: "Aktuell.",
      statusResetReq: "ZurÃ¼cksetzen angefordertâ€¦",
      statusDisconnected: "Getrennt.",
      bkTip: "",
      backupStart: (n)=>`Backup wird erstelltâ€¦`,
      backupDone:  "Backup bereit.",
      restoreStart:"Wiederherstellenâ€¦",
      restoreDone: "Wiederherstellung abgeschlossen."
    }
  };

  const $ = id => document.getElementById(id);
  let lang = 'en';
  const statusLine = $('status');

  function fmtMs(ms){
    if (ms == null || isNaN(ms)) return 'â€”';
    ms = Math.max(0, Math.round(ms));
    if (ms < 1000) return `${ms} ms`;
    let s = Math.floor(ms/1000);
    if (s < 60) return `${s}s`;
    let m = Math.floor(s/60); s = s % 60;
    if (m < 60) return `${m}m ${s}s`;
    let h = Math.floor(m/60); m = m % 60;
    return `${h}h ${m}m ${s}s`;
  }

  function applyI18n() {
    const L = i18n[lang];
    $('titleTxt').textContent   = L.title;
    $('connectBtn').textContent = L.connect;
    $('refreshBtn').textContent = L.refresh;
    $('resetBtn').textContent   = L.reset;
    $('disconnectBtn').textContent = L.disconnect;
    $('backupBtn').textContent  = L.backup;
    $('restoreBtn').textContent = L.restore;
    statusLine.textContent = L.statusNot;

    $('overviewTitle').textContent = L.overview;
    $('lblBeads').textContent   = L.beads;
    $('lblDecades').textContent = L.decades;
    $('lblRosaries').textContent= L.rosaries;

    $('avgTitle').textContent = L.averages;
    $('lblAvgBead').textContent   = L.avgBead;
    $('lblAvgDecade').textContent = L.avgDecade;
    $('lblAvgRosary').textContent = L.avgRosary;
    $('avgNote').textContent      = L.avgNote;

    $('barTitle').textContent   = L.barTitle;
    $('donutTitle').textContent = L.donutTitle;
    $('partsTitle').textContent = L.partsTitle;
    $('bkNote').textContent     = L.bkTip;

    // Update chart labels
    barWindow.data.labels = [L.chartBead, L.chartDecade, L.chartRosary];
    donutSets.data.labels = L.sets.slice();
    partsChart.data.labels = [L.sets[0], L.sets[1], L.sets[4], L.sets[2], L.sets[3]]; // None, Joyful, Luminous, Sorrowful, Glorious (UI order)
    barWindow.update(); donutSets.update(); partsChart.update();
  }

  function u8ToStr(v){ return new TextDecoder().decode(v); }
  function safeNum(x, d=0){ const v = Number(x); return isFinite(v) ? v : d; }

  /* Charts */
  const barWindow = new Chart($('barWindow').getContext('2d'), {
    type: 'bar',
    data: { labels: ['Bead','Decade','Rosary'], datasets: [{ label: 'Avg (s)', data: [0, 0, 0] }] },
    options: {
      responsive:true, maintainAspectRatio:false,
      scales:{ y:{ beginAtZero:true, ticks:{ precision:0 }, grid:{ color:'#1a2733' } }, x:{ grid:{ color:'#1a2733' } } },
      plugins:{ legend:{ display:false } }
    }
  });

  const donutSets = new Chart($('donutSets').getContext('2d'), {
    type: 'doughnut',
    data: {
      labels: ['None','Joyful','Sorrowful','Glorious','Luminous'],
      datasets: [{
        data: [0, 0, 0, 0, 0],
        backgroundColor: ['#808080','#ffcc00','#cc0000','#00cc00','#3399ff'],
        borderColor: '#0b0f14', borderWidth: 2
      }]
    },
    options: { responsive:true, maintainAspectRatio:false, plugins:{ legend:{ position:'bottom', labels:{ color:'#eaf0f6' } } }, cutout:'60%' }
  });

  const partsCtx = $('partsChart').getContext('2d');
  const partShades = {
    none:      ['#9e9e9e','#8f8f8f','#808080','#717171','#626262'],
    joyful:    ['#ffe680','#ffdb4d','#ffcc00','#e6b800','#cc9a00'],
    sorrowful: ['#ff6666','#ff3333','#cc0000','#990000','#730000'],
    glorious:  ['#66ff66','#33e633','#00cc00','#00a300','#007a00'],
    luminous:  ['#99ccff','#66b2ff','#3399ff','#1a7fd6','#0066cc'],
  };
  const partsChart = new Chart(partsCtx, {
    type: 'bar',
    data: {
      labels: ['None','Joyful','Luminous','Sorrowful','Glorious'],
      datasets: [
        { label: 'I',  data: [0,0,0,0,0], backgroundColor: [partShades.none[0],partShades.joyful[0],partShades.luminous[0],partShades.sorrowful[0],partShades.glorious[0]] },
        { label: 'II', data: [0,0,0,0,0], backgroundColor: [partShades.none[1],partShades.joyful[1],partShades.luminous[1],partShades.sorrowful[1],partShades.glorious[1]] },
        { label: 'III',data: [0,0,0,0,0], backgroundColor: [partShades.none[2],partShades.joyful[2],partShades.luminous[2],partShades.sorrowful[2],partShades.glorious[2]] },
        { label: 'IV', data: [0,0,0,0,0], backgroundColor: [partShades.none[3],partShades.joyful[3],partShades.luminous[3],partShades.sorrowful[3],partShades.glorious[3]] },
        { label: 'V',  data: [0,0,0,0,0], backgroundColor: [partShades.none[4],partShades.joyful[4],partShades.luminous[4],partShades.sorrowful[4],partShades.glorious[4]] },
      ]
    },
    options: {
      responsive:true, maintainAspectRatio:false,
      plugins:{ legend:{ position:'bottom', labels:{ color:'#eaf0f6' } } },
      scales:{
        x:{ stacked:true, grid:{ color:'#1a2733' }, ticks:{ color:'#cfe4ff' } },
        y:{ stacked:true, beginAtZero:true, grid:{ color:'#1a2733' }, ticks:{ color:'#cfe4ff', precision:0 } }
      }
    }
  });

async function connectBLE(){
  const L = i18n[lang];
  try{
    if (!navigator.bluetooth) throw new Error(L.errWB);
    statusLine.textContent = 'Requesting deviceâ€¦';

    let dev;
    try {
      dev = await navigator.bluetooth.requestDevice({
        filters: [{ services: [OTA_SVC_UUID] }],
        optionalServices: [OTA_SVC_UUID]
      });
    } catch {
      dev = await navigator.bluetooth.requestDevice({
        acceptAllDevices: true,
        optionalServices: [OTA_SVC_UUID]
      });
      if (!dev.name || !dev.name.toLowerCase().startsWith('rosary')) {
        throw new Error(L.errPick);
      }
    }

    device = dev;
    device.addEventListener('gattserverdisconnected', onDisconnected);

    statusLine.textContent = 'Connectingâ€¦';
    server  = await device.gatt.connect();

    // ðŸ”§ Android quirk: give the GATT a moment to finish service discovery.
    await sleep(300);

    // Get service/characteristics with retries (Android sometimes races here)
    service   = await withRetry(() => server.getPrimaryService(OTA_SVC_UUID));
    chSettings= await withRetry(() => service.getCharacteristic(INFO_SETTINGS_UUID));
    chParts   = await withRetry(() => service.getCharacteristic(INFO_PARTS_UUID));
    chStats   = await withRetry(() => service.getCharacteristic(INFO_STATS_UUID));
    chCtrl    = await withRetry(() => service.getCharacteristic(INFO_CTRL_UUID));

    $('refreshBtn').disabled = false;
    $('resetBtn').disabled   = false;
    $('backupBtn').disabled  = false;
    $('restoreBtn').disabled = false;
    $('disconnectBtn').disabled = true;

    statusLine.textContent = L.statusConnected;

    // First reads with retry (smaller ones first)
    await withRetry(refresh);

    $('disconnectBtn').disabled = false;
  } catch(err){
    console.error(err);
    statusLine.textContent = 'Error: ' + err.message;
  }
}

async function refresh(){
  const L = i18n[lang];
  try{
    if (!chStats || !chSettings) return;

    // Android quirk: give discovery/MTU a moment before first reads
    await sleep(200);

    // Read small blobs first (settings, parts), then the big stats blob last.
    const [vSettings, vPartsMaybe] = await Promise.all([
      readWithRetry(chSettings),
      chParts ? readWithRetry(chParts).catch(()=>null) : Promise.resolve(null)
    ]);

    // Stats is usually the largest â€“ do it after a tiny pause and with retry.
    await sleep(80);
    const vStats = await readWithRetry(chStats);

    const jsStats    = JSON.parse(u8ToStr(vStats));
    const jsSettings = JSON.parse(u8ToStr(vSettings));

    $('kpiBeads').textContent    = (jsStats.totals?.beads ?? 'â€”');
    $('kpiDecades').textContent  = (jsStats.totals?.decades ?? 'â€”');
    $('kpiRosaries').textContent = (jsStats.totals?.rosaries ?? 'â€”');

    const Ldev = i18n[lang];
    $('pillDevice').textContent = `${Ldev.device}: ${jsStats.device || 'â€”'}`;
    $('pillFW').textContent     = `${Ldev.firmware}: ${jsSettings.fwVersion || 'â€”'}`;
    $('pillLastMystery').textContent =
      `${Ldev.lastMystery}: ${jsStats.lastMystery?.set || 'â€”'}${jsStats.lastMystery?.index ? ` #${jsStats.lastMystery.index}` : ''}`;

    // Durations
    const d = jsStats.durations || {};
    const avgBeadMs   = safeNum(d.avgBeadMs,   0);
    const avgDecadeMs = safeNum(d.avgDecadeMs, 0);
    const avgRosaryMs = safeNum(d.avgRosaryMs, 0);
    const totBeadMs   = safeNum(d.totalBeadMs,   0);
    const totDecadeMs = safeNum(d.totalDecadeMs, 0);
    const totRosaryMs = safeNum(d.totalRosaryMs, 0);

    $('kpiAvgBead').textContent   = fmtMs(avgBeadMs);
    $('kpiAvgDecade').textContent = fmtMs(avgDecadeMs);
    $('kpiAvgRosary').textContent = fmtMs(avgRosaryMs);

    $('totRosary').textContent = fmtMs(totRosaryMs);
    $('totDecade').textContent = fmtMs(totDecadeMs);
    $('totBead').textContent   = fmtMs(totBeadMs);

    barWindow.data.datasets[0].data = [avgBeadMs/1000, avgDecadeMs/1000, avgRosaryMs/1000];
    barWindow.update();

    // Sets
    const totalDec = (jsStats.totals?.decades ?? 0);
    const joyful   = (jsStats.sets?.joyful ?? 0);
    const sorrow   = (jsStats.sets?.sorrowful ?? 0);
    const glor     = (jsStats.sets?.glorious ?? 0);
    const lumi     = (jsStats.sets?.luminous ?? 0);
    let none       = jsStats.sets?.none;
    if (none == null) {
      const sumKnown = joyful + sorrow + glor + lumi;
      none = Math.max(0, totalDec - sumKnown);
    }
    donutSets.data.datasets[0].data = [none, joyful, sorrow, glor, lumi];
    donutSets.update();

    // Parts (optional char; tolerate failures)
    if (vPartsMaybe) {
      try {
        const jsParts = JSON.parse(u8ToStr(vPartsMaybe));
        const sp = jsParts.setsParts || {};
        const setsOrder = ['none','joyful','luminous','sorrowful','glorious']; // UI order
        const dataByPart = [0,1,2,3,4].map(()=>[0,0,0,0,0]);

        setsOrder.forEach((name, si) => {
          const arr = sp[name] || [0,0,0,0,0];
          for (let p=0;p<5;p++) dataByPart[p][si] = Number(arr[p]||0);
        });
        for (let p=0;p<5;p++) partsChart.data.datasets[p].data = dataByPart[p];
        partsChart.update();
      } catch(e) {
        console.warn('Parts parse/read failed:', e);
      }
    }

    statusLine.textContent = L.statusUpdated;
  } catch(err){
    console.error(err);
    statusLine.textContent = 'Read failed: ' + err.message;
  }
}

  async function resetStats(){
    const L = i18n[lang];
    try{
      if (!chCtrl) return;
      if (!confirm(L.confirmReset)) return;
      await chCtrl.writeValue(new Uint8Array([0x01]));
      setTimeout(refresh, 300);
      statusLine.textContent = L.statusResetReq;
    } catch(err){
      console.error(err);
      statusLine.textContent = 'Reset failed: ' + err.message;
    }
  }

  function onDisconnected(){
    const L = i18n[lang];
    statusLine.textContent = L.statusDisconnected;
    $('refreshBtn').disabled = true;
    $('resetBtn').disabled   = true;
    $('disconnectBtn').disabled = true;
    $('backupBtn').disabled  = true;
    $('restoreBtn').disabled = true;
  }

  async function disconnectBLE(){
    try { if (device && device.gatt.connected) await device.gatt.disconnect(); }
    catch (e) { console.warn(e); }
    finally { onDisconnected(); }
  }
  

  // --- helpers for flaky Android GATT reads ---
async function reacquireChars() {
  // Re-fetch service & characteristics from the current server
  service    = await withRetry(() => server.getPrimaryService(OTA_SVC_UUID));
  chSettings = await withRetry(() => service.getCharacteristic(INFO_SETTINGS_UUID));
  // parts is optional
  try { chParts = await withRetry(() => service.getCharacteristic(INFO_PARTS_UUID)); }
  catch { chParts = null; }
  chStats    = await withRetry(() => service.getCharacteristic(INFO_STATS_UUID));
  chCtrl     = await withRetry(() => service.getCharacteristic(INFO_CTRL_UUID));
}

async function robustRead(ch) {
  // Try a normal read
  try { return await readWithRetry(ch); }
  catch (e1) {
    console.warn('read failed once, reacquiring charsâ€¦', e1);
    // Reacquire handles (Android sometimes invalidates them)
    await sleep(200);
    await reacquireChars();
    try { return await readWithRetry(ch); }
    catch (e2) {
      console.warn('read failed after reacquire, reconnectingâ€¦', e2);
      // Full reconnect, then reacquire and retry once more
      try { if (device?.gatt?.connected) device.gatt.disconnect(); } catch {}
      await sleep(250);
      server = await device.gatt.connect();
      await sleep(300);
      await reacquireChars();
      return await readWithRetry(ch);
    }
  }
}

// ---- Backup (Android friendly: paced reads + reacquire/reconnect fallback) ----
async function doBackup(){
  const L = i18n[lang];
  try{
    if (!chStats || !chSettings) return;
    statusLine.textContent = L.backupStart();

    // small settle
    await sleep(150);

    // Read smaller blobs first, then the larger stats (each via robustRead)
    const vSettings = await robustRead(chSettings);

    let vParts = null;
    if (chParts) {
      try { vParts = await robustRead(chParts); }
      catch (e) { console.warn('parts read skipped:', e); }
    }

    await sleep(80);
    const vStats = await robustRead(chStats);

    const jsStats    = JSON.parse(u8ToStr(vStats));
    const jsSettings = JSON.parse(u8ToStr(vSettings));

    // Ensure duration counters exist for reliable restore of averages
    const d = jsStats?.durations || {};
    const beadSum = Number(d.totalBeadMs ?? 0);
    const decSum  = Number(d.totalDecadeMs ?? 0);
    const rosSum  = Number(d.totalRosaryMs ?? 0);

    let beadCnt = Number(d.beadIntervals || 0);
    let decCnt  = Number(d.decadeCount   || 0);
    let rosCnt  = Number(d.rosaryCount   || 0);

    if (!beadCnt) {
      const avg = Number(d.avgBeadMs || 0);
      beadCnt = avg > 0 ? Math.floor(beadSum / avg) : 0;
    }
    if (!decCnt) {
      const avg = Number(d.avgDecadeMs || 0);
      decCnt = avg > 0 ? Math.floor(decSum / avg) : 0;
    }
    if (!rosCnt) {
      const avg = Number(d.avgRosaryMs || 0);
      rosCnt = avg > 0 ? Math.floor(rosSum / avg) : 0;
    }

    jsStats.durations = {
      ...d,
      beadIntervals: beadCnt,
      decadeCount:   decCnt,
      rosaryCount:   rosCnt,
      totalBeadMs:   String(beadSum),
      totalDecadeMs: String(decSum),
      totalRosaryMs: String(rosSum)
    };

    const js = {
      device:    jsStats.device || '',
      fwVersion: jsSettings.fwVersion || '',
      stats:     jsStats,
      settings:  jsSettings,
      setsParts: null
    };

    if (vParts) {
      try {
        const jp = JSON.parse(u8ToStr(vParts));
        js.setsParts = jp.setsParts || null;
      } catch(e) {
        console.warn('Parts JSON parse skipped:', e);
      }
    }

    const blob = new Blob([JSON.stringify(js, null, 2)], { type: 'application/json' });
    const url  = URL.createObjectURL(blob);
    const a    = document.createElement('a');
    a.href = url;
    a.download = (js.device || 'rosary') + '_backup.json';
    a.click();
    URL.revokeObjectURL(url);

    statusLine.textContent = L.backupDone;
  } catch(err){
    console.error(err);
    statusLine.textContent = 'Backup failed: ' + err.message;
  }
}

  // ---- Restore (upload JSON -> many small SET_* writes) ----
  function le16(n){ const a=new Uint8Array(2); n=Number(n)>>>0; a[0]=n&255; a[1]=(n>>8)&255; return a; }  // <-- added
  function le32(n){ const a=new Uint8Array(4); n = Number(n)>>>0; a[0]=n&255; a[1]=(n>>8)&255; a[2]=(n>>16)&255; a[3]=(n>>24)&255; return a; }
  function le64Big(n){ // BigInt
    const a = new Uint8Array(8); let x = BigInt(n);
    for (let i=0;i<8;i++){ a[i] = Number(x & 0xffn); x >>= 8n; }
    return a;
  }
  function packKV(op, type, key, valBytes){
    const k = new TextEncoder().encode(key);
    const out = new Uint8Array(1 + 1 + 1 + k.length + valBytes.length);
    out[0]=op; out[1]=type; out[2]=k.length; out.set(k,3); out.set(valBytes, 3+k.length);
    return out;
  }
  // size of encoded value for progress accounting (no payload allocation)
  function encSize(type, value){
    switch (type){
      case 0x01: return 1; // bool
      case 0x11: return 1; // u8
      case 0x12: return 2; // u16
      case 0x14: return 4; // u32
      case 0x21: return 4; // i32
      case 0x18: return 8; // u64
      case 0x31: return new TextEncoder().encode(String(value)).length; // str
      default: throw new Error('bad type');
    }
  }

  async function writePrefKey(key, type, value){
    let valBytes;
    switch (type){
      case 0x01: valBytes = new Uint8Array([value?1:0]); break;
      case 0x11: valBytes = new Uint8Array([Number(value) & 0xff]); break;
      case 0x12: { const v=Number(value)>>>0; valBytes = new Uint8Array([v & 0xff, (v>>8)&0xff]); } break;
      case 0x14: valBytes = le32(value); break;
      case 0x21: valBytes = le32(value); break;
      case 0x18: valBytes = le64Big(BigInt(value)); break;
      case 0x31: valBytes = new TextEncoder().encode(String(value)); break;
      default: throw new Error('bad type');
    }
    const payload = packKV(OP_SET_PREF, type, key, valBytes);
    await chCtrl.writeValue(payload);
  }
  async function writeStatKey(key, type, value){
    let valBytes;
    switch (type){
      case 0x11: valBytes = new Uint8Array([Number(value) & 0xff]); break;
      case 0x12: { const v=Number(value)>>>0; valBytes = new Uint8Array([v & 0xff, (v>>8)&0xff]); } break;
      case 0x14: valBytes = le32(value); break;
      case 0x18: valBytes = le64Big(BigInt(value)); break;
      default: throw new Error('bad type');
    }
    const payload = packKV(OP_SET_STAT, type, key, valBytes);
    await chCtrl.writeValue(payload);
  }

  async function restoreFromJson(js, onProgress){
    // prefs mapping per Settings::load()
    const prefs = js.settings || js.prefs || {};
    const stAll = js.stats || {};

    const totalSteps =
      13 + // prefs
      5 + 3 + 2 + 30 + 5 + (5*5) + 6; // stats keys we write below
    let step=0;
    const tick = ()=>onProgress?.(++step, totalSteps);

    // ---- PREPASS: compute totalBytes for RESTORE_BEGIN ----
    let totalBytes = 0;
    const sumKV = (key, type, value) => { totalBytes += key.length + encSize(type, value); };

    // prefs booleans
    sumKV("haptic-en",     0x01, !!prefs.haptic);
    sumKV("m-preset-en",   0x01, !!(prefs.mystery?.preset));
    sumKV("m-autosave-en", 0x01, !!(prefs.mystery?.autosave));
    sumKV("m-intro-en",    0x01, !!(prefs.mystery?.intro));
    sumKV("i-en",          0x01, !!(prefs.intentions?.enabled));

    // prefs ints
    sumKV("disp-bright",   0x21, prefs.display?.brightness ?? 0);
    sumKV("disp-rot",      0x21, prefs.display?.rotation ?? 0);
    sumKV("wall-bright",   0x21, prefs.wallpaper?.brightness ?? 0);
    sumKV("ImageIndex",    0x21, prefs.wallpaper?.imageIndex ?? 0);
    sumKV("beadIndex",     0x21, prefs.mystery?.beadIndex ?? -1);
    sumKV("m-pos",         0x21, prefs.mystery?.pos ?? 0);
    sumKV("m-part",        0x21, prefs.mystery?.part ?? 0);
    sumKV("i-pos",         0x21, prefs.intentions?.pos ?? 0);

    // stats scalars
    const totals = stAll.totals || {};
    sumKV("beads",    0x14, totals.beads    ?? 0);
    sumKV("paters",   0x14, totals.paters   ?? 0);
    sumKV("glorias",  0x14, totals.glorias  ?? 0);
    sumKV("decades",  0x14, totals.decades  ?? 0);
    sumKV("rosaries", 0x14, totals.rosaries ?? 0);

    // last mystery + ts
    const last = stAll.lastMystery || {};
    const setMap = { None:0, Joyful:1, Luminous:2, Sorrowful:3, Glorious:4 };
    sumKV("lastSet", 0x11, setMap[last.set] ?? 0);
    sumKV("lastIdx", 0x11, last.index ?? 0);
    sumKV("lastTs",  0x14, stAll.lastPrayer ?? 0);

    // streak + baseDay
    sumKV("streak",  0x12, stAll.streakDays ?? 0);
    sumKV("baseDay", 0x14, 0);

    // ring[30]
    const ring = stAll.ring || [];
    for (let i=0;i<30;i++){
      const key = `r${String(i).padStart(2,'0')}`;
      sumKV(key, 0x12, ring[i] ?? 0);
    }

    // sets totals set0..set4
    const sets = stAll.sets || {};
    const order = ['none','joyful','luminous','sorrowful','glorious'];
    for (let si=0; si<5; si++){
      sumKV(`set${si}`, 0x14, sets[order[si]] ?? 0);
    }

    // parts pXY
    const sp = js.setsParts || stAll.setsParts || {};
    for (let si=0; si<5; si++){
      const arr = sp[order[si]] || [0,0,0,0,0];
      for (let pi=0; pi<5; pi++){
        sumKV(`p${si}${pi}`, 0x14, arr[pi] ?? 0);
      }
    }

    // durations: sums+counts
    const dur = stAll.durations || {};
    sumKV("bSum", 0x18, BigInt(dur.totalBeadMs   ?? 0));
    sumKV("bInt", 0x14, (dur.beadIntervals ?? 0));
    sumKV("dSum", 0x18, BigInt(dur.totalDecadeMs ?? 0));
    sumKV("dCnt", 0x14, (dur.decadeCount  ?? 0));
    sumKV("rSum", 0x18, BigInt(dur.totalRosaryMs ?? 0));
    sumKV("rCnt", 0x14, (dur.rosaryCount  ?? 0));

    // Send RESTORE_BEGIN so ESP32 can display progress based on bytes
    const begin = new Uint8Array(1+2+4);
    begin[0] = OP_REST_BEGIN;
    begin.set(le16(totalSteps), 1);
    begin.set(le32(totalBytes), 3);
    await chCtrl.writeValue(begin);

    // ---- ACTUAL WRITES (unchanged), with onProgress ticks ----

    // prefs booleans
    await writePrefKey("haptic-en",     0x01, !!prefs.haptic);                     tick();
    await writePrefKey("m-preset-en",   0x01, !!(prefs.mystery?.preset));          tick();
    await writePrefKey("m-autosave-en", 0x01, !!(prefs.mystery?.autosave));        tick();
    await writePrefKey("m-intro-en",    0x01, !!(prefs.mystery?.intro));           tick();
    await writePrefKey("i-en",          0x01, !!(prefs.intentions?.enabled));      tick();

    // prefs ints
    await writePrefKey("disp-bright",   0x21, prefs.display?.brightness ?? 0);     tick();
    await writePrefKey("disp-rot",      0x21, prefs.display?.rotation ?? 0);       tick();
    await writePrefKey("wall-bright",   0x21, prefs.wallpaper?.brightness ?? 0);   tick();
    await writePrefKey("ImageIndex",    0x21, prefs.wallpaper?.imageIndex ?? 0);   tick();
    await writePrefKey("beadIndex",     0x21, prefs.mystery?.beadIndex ?? -1);     tick();
    await writePrefKey("m-pos",         0x21, prefs.mystery?.pos ?? 0);            tick();
    await writePrefKey("m-part",        0x21, prefs.mystery?.part ?? 0);           tick();
    await writePrefKey("i-pos",         0x21, prefs.intentions?.pos ?? 0);         tick();

    // stats scalars (from js.stats schema produced by firmware)
    await writeStatKey("beads",    0x14, totals.beads    ?? 0); tick();
    await writeStatKey("paters",   0x14, totals.paters   ?? 0); tick();
    await writeStatKey("glorias",  0x14, totals.glorias  ?? 0); tick();
    await writeStatKey("decades",  0x14, totals.decades  ?? 0); tick();
    await writeStatKey("rosaries", 0x14, totals.rosaries ?? 0); tick();

    // last mystery + ts (legacy)
    await writeStatKey("lastSet", 0x11, setMap[last.set] ?? 0);     tick();
    await writeStatKey("lastIdx", 0x11, last.index ?? 0);           tick();
    await writeStatKey("lastTs",  0x14, stAll.lastPrayer ?? 0);     tick();

    // streak + baseDay (we keep baseDay 0)
    await writeStatKey("streak",  0x12, stAll.streakDays ?? 0);     tick();
    await writeStatKey("baseDay", 0x14, 0);                         tick();

    // ring[30] -> r00..r29 (if present; else zeros)
    for (let i=0;i<30;i++){
      const key = `r${String(i).padStart(2,'0')}`;
      await writeStatKey(key, 0x12, ring[i] ?? 0);                  tick();
    }

    // sets totals set0..set4
    for (let si=0; si<5; si++){
      await writeStatKey(`set${si}`, 0x14, sets[order[si]] ?? 0);   tick();
    }

    // parts pXY
    for (let si=0; si<5; si++){
      const arr = sp[order[si]] || [0,0,0,0,0];
      for (let pi=0; pi<5; pi++){
        await writeStatKey(`p${si}${pi}`, 0x14, arr[pi] ?? 0);      tick();
      }
    }

    // durations: write sums+counts used by getters
    await writeStatKey("bSum", 0x18, BigInt(dur.totalBeadMs   ?? 0)); tick();
    await writeStatKey("bInt", 0x14, (dur.beadIntervals ?? 0));       tick();
    await writeStatKey("dSum", 0x18, BigInt(dur.totalDecadeMs ?? 0)); tick();
    await writeStatKey("dCnt", 0x14, (dur.decadeCount  ?? 0));        tick();
    await writeStatKey("rSum", 0x18, BigInt(dur.totalRosaryMs ?? 0)); tick();
    await writeStatKey("rCnt", 0x14, (dur.rosaryCount  ?? 0));        tick();

    // ask device to refresh JSON chars
    await chCtrl.writeValue(new Uint8Array([OP_REST_DONE]));
  }

  // UI wiring
  $('connectBtn').addEventListener('click', connectBLE);
  $('refreshBtn').addEventListener('click', refresh);
  $('resetBtn').addEventListener('click', resetStats);
  $('disconnectBtn').addEventListener('click', disconnectBLE);
  $('backupBtn').addEventListener('click', doBackup);

  $('restoreBtn').addEventListener('click', () => $('restoreFile').click());
  $('restoreFile').addEventListener('change', async (e)=>{
    const f = e.target.files[0];
    if (!f) return;
    const L = i18n[lang];
    const prog = $('restoreProg'); prog.hidden = false; prog.value = 0;
    const text = await f.text();
    let js;
    try { js = JSON.parse(text); } catch { alert('Bad JSON'); prog.hidden=true; return; }
    statusLine.textContent = L.restoreStart;
    const onProg = (step,total)=>{ prog.value = Math.floor(step*100/total); };
    try{
      await restoreFromJson(js, onProg);
      await refresh();
      statusLine.textContent = L.restoreDone;
    } catch(err){
      console.error(err);
      statusLine.textContent = 'Restore failed: ' + err.message;
    } finally {
      setTimeout(()=>{ prog.hidden = true; }, 600);
      e.target.value = '';
    }
  });

  // Language selector
  $('langSelect').addEventListener('change', (ev)=>{ lang = ev.target.value; applyI18n(); });

  // Initial i18n
  applyI18n();
  </script>
</body>
</html>