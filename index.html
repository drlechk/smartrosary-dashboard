<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" type="image/svg+xml" href="favicon.svg">
<title>SmartRosary — Dashboard</title>
<link rel="stylesheet" href="styles.css">
</head>
<body>
  <header class="header-with-lang">
    <h1 id="titleTxt">SmartRosary — Dashboard</h1>
    <select id="langSelect">
      <option value="pl">PL</option>
      <option value="en">EN</option>
      <option value="de">DE</option>
    </select>
  </header>

  <div class="toolbar-wrap">
    <div class="toolbar">
      <button id="connectBtn">Connect</button>
      <button id="refreshBtn" disabled>Refresh</button>
      <button id="disconnectBtn" disabled>Disconnect</button>
    </div>
  </div>

  <div id="status">Not connected.</div>

  <section class="wrap">
    <div class="grid">
      <div class="card">
        <h3 id="overviewTitle">Overview</h3>
        <div class="kpis" style="grid-template-columns:repeat(3,1fr);">
          <div class="kpi"><div class="label" id="lblBeads">Beads</div><div class="value" id="kpiBeads">—</div></div>
          <div class="kpi"><div class="label" id="lblDecades">Decades</div><div class="value" id="kpiDecades">—</div></div>
          <div class="kpi"><div class="label" id="lblRosaries">Rosaries</div><div class="value" id="kpiRosaries">—</div></div>
          <div class="kpi"><div class="label" id="lblChaplets">Chaplets</div><div class="value" id="kpiChaplets">—</div></div>
        </div>
        <div class="flex" style="margin-top:12px;">
          <span class="pill" id="pillDevice"><span id="lblDevice">Device</span>: <span id="valDevice">—</span></span>
          <span class="pill" id="pillFW"><span id="lblFW">FW</span>: <span id="valFW">—</span></span>
          <span class="pill" id="pillLastMystery"><span id="lblLastMystery">Last mystery</span>: <span id="valLastMystery">—</span></span>
        </div>
        <p class="smallnote" id="bkNote"></p></br>
        <h3 id="lblBackupRestore">Backup & Restore</h3>
        <div class="row">
          <button id="backupBtn"  disabled>Download</button>
          <input type="file" id="restoreFile" accept="application/json" style="display:none">
          <button id="restoreBtn" disabled>Restore</button>
          <button id="resetBtn" disabled>Reset Statistics</button>
          <progress id="restoreProg" max="100" value="0" hidden></progress>
        </div>
      </div>

      <div class="card">
        <h3 id="settingsTitle">Settings</h3>
        <div class="settings-list">
           <div class="setting">
            <div class="meta">
              <span class="title" id="lblPreset">Start with preset mystery</span>
              <span class="desc"  id="descPreset">Begin rosary on a chosen set (disables autosave).</span>
            </div>
            <label class="switch">
              <input type="checkbox" id="swPreset" disabled>
              <span class="slider"></span>
            </label>
          </div>
          <div class="setting">
            <div class="meta">
              <span class="title" id="lblAutosave">Autosave last state</span>
              <span class="desc"  id="descAutosave">Continue where you left off.</span>
            </div>
            <label class="switch">
              <input type="checkbox" id="swAutosave" disabled>
              <span class="slider"></span>
            </label>
          </div>
          <div class="setting">
            <div class="meta">
              <span class="title" id="lblHaptic">Haptic feedback</span>
              <span class="desc"  id="descHaptic">Vibration on key/bead events.</span>
            </div>
            <label class="switch">
              <input type="checkbox" id="swHaptic" disabled>
              <span class="slider"></span>
            </label>
          </div>
         <div class="setting" style="display:flex; justify-content:space-between; align-items:center;">
            <div class="meta">
              <span class="title" id="lblDispBright">Display brightness</span>
              <span class="desc"  id="descDispBright">
                Adjust screen backlight (0–100).
              </span>
            </div>
            <div style="display:flex; align-items:center; gap:10px;">
              <input id="slDispBright" type="range" min="0" max="100" step="1" value="0" disabled
                    style="width:140px;">
              <span id="slDispBrightVal" class="pill" style="min-width:48px; text-align:center;">0%</span>
            </div>
          </div>
          <div class="setting" style="display:flex; justify-content:space-between; align-items:center;">
            <div class="meta">
              <span class="title" id="lblWallBright">Wallpaper brightness</span>
              <span class="desc"  id="descWallBright">Adjust background image opacity.</span>
            </div>
            <div style="display:flex; align-items:center; gap:10px;">
              <input
                type="range"
                id="slWallBright"
                min="0"
                max="100"
                value="0"
                disabled
                style="width:140px"
              />
              <span id="wallBrightVal" class="pill" style="min-width:48px; text-align:center;">0%</span>
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <h3 id="avgTitle">Durations & Averages</h3>
         <div class="kpis" style="grid-template-columns:repeat(3,1fr);">
          <div class="kpi"><div class="label" id="lblAvgBead">Avg bead</div><div class="value" id="kpiAvgBead">—</div></div>
          <div class="kpi"><div class="label" id="lblAvgDecade">Avg decade</div><div class="value" id="kpiAvgDecade">—</div></div>
          <div class="kpi"><div class="label" id="lblAvgRosary">Avg rosary</div><div class="value" id="kpiAvgRosary">—</div></div>
          <div class="kpi"><div class="label" id="lblAvgChaplet">Avg chaplet</div><div class="value" id="kpiAvgChaplet">—</div></div>
        </div>
        <p class="smallnote" id="avgNote">Averages are computed from lifetime device totals.</p>
        <h3 id="totalsTitle">Totals (time)</h3>
        <div class="kpis" style="grid-template-columns:repeat(3,1fr);">
          <div class="kpi"><div class="label" id="lblTrosary">Rosary</div><div class="value" id="totRosary">—</div></div>
          <div class="kpi"><div class="label" id="lblTdecades">Decades</div><div class="value" id="totDecade">—</div></div>
          <div class="kpi"><div class="label" id="lblTbeads">Beads</div><div class="value" id="totBead">—</div></div>
          <div class="kpi"><div class="label" id="lblTchaplet">Chaplet</div><div class="value" id="totChaplet">—</div></div>
        </div>
      </div>

      <div class="card">
        <h3 id="barTitle">Average durations (s)</h3>
        <div class="chart"><canvas id="barWindow"></canvas></div>
      </div>

      <div class="card">
        <h3 id="donutTitle">Mystery Sets Breakdown</h3>
        <div class="chart"><canvas id="donutSets"></canvas></div>
      </div>

      <div class="card">
        <h3 id="partsTitle">Mystery Parts (I–V per set)</h3>
        <div class="chart"><canvas id="partsChart"></canvas></div>
      </div>


      <div class="card">
        <h3 id="rcTitle">Remote control</h3>
        <div class="remote-wrap">
          <div class="canvas-shell">
            <canvas id="lvgl_canvas" width="320" height="320" aria-label="Round touch surface"></canvas>
          </div>
          <div class="dpad" role="group" aria-label="LVGL directions + center">
            <div class="empty"></div>
            <button id="btnUp"    aria-label="Top">▲</button>
            <div class="empty"></div>

            <button id="btnLeft"  aria-label="Left">◀</button>
            <button id="btnCenter" class="center" aria-label="Center">●</button>
            <button id="btnRight" aria-label="Right">▶</button>

            <div class="empty"></div>
            <button id="btnDown"  aria-label="Bottom">▼</button>
            <div class="empty"></div>
          </div>
          <div id="rcStatus">Touch + D-pad will activate after connecting.</div>
        </div>
      </div>
    </div>
  </section>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script type="module">import { i18n } from './i18n.js';
  /* UUIDs — MUST match firmware (unchanged) */
  const OTA_SVC_UUID       = '12345678-1234-5678-1234-56789abcdef0';
  const INFO_STATS_UUID    = 'b8a7a0e2-1a5d-4c1e-9d93-2c9e2b9e1001';
  const INFO_SETTINGS_UUID = 'b8a7a0e2-1a5d-4c1e-9d93-2c9e2b9e1002';
  const INFO_CTRL_UUID     = 'b8a7a0e2-1a5d-4c1e-9d93-2c9e2b9e10ff';
  const INFO_PARTS_UUID    = 'b8a7a0e2-1a5d-4c1e-9d93-2c9e2b9e1003';
  // ==== Remote control UUIDs (characteristics under your existing service) ====
  const TOUCH_CHAR_UUID = '12345678-1234-5678-1234-56789abcdea1'; // 5-byte pointer
  const KEYS_CHAR_UUID  = '12345678-1234-5678-1234-56789abcdea2'; // 1-byte command

  const STATUS_UUID = '12345678-1234-5678-1234-56789abcdef2'; 

  // Control opcodes
  const OP_SET_PREF  = 0x50;
  const OP_SET_STAT  = 0x53;
  const OP_REST_DONE = 0x55;
  const OP_REST_BEGIN= 0x54;

  // LVGL directions / center command
  const LV = { LEFT:2, RIGHT:1, TOP:8, BOTTOM:4 };
  const CMD_CENTER = 16;

  let touchChar = null, keysChar = null;
  const canvasRC = document.getElementById('lvgl_canvas');
  const btnUp = document.getElementById('btnUp');
  const btnDown = document.getElementById('btnDown');
  const btnLeft = document.getElementById('btnLeft');
  const btnRight = document.getElementById('btnRight');
  const btnCenter = document.getElementById('btnCenter');
  const rcStatus = document.getElementById('rcStatus');

  function setDpadEnabled(en){
    [btnUp, btnDown, btnLeft, btnRight, btnCenter].forEach(b => b.disabled = !en);
  }
  setDpadEnabled(false);

  function setRemoteMuted(muted){
    const card = canvasRC.closest('.card');
    if (!card) return;
    card.classList.toggle('remote-muted', muted);
  }
  setRemoteMuted(true);

  let device, server, service, chStats, chSettings, chCtrl, chParts;

  let statusChar = null;
  let readyFlag = true; // gate writes; true = allowed to write next

  function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

  async function withRetry(fn, {tries=5, base=120} = {}) {
    let err;
    for (let i=0;i<tries;i++){
      try { return await fn(); }
      catch(e){ err = e; await sleep(base * Math.pow(1.6, i)); }
    }
    throw err;
  }

  async function readWithRetry(ch, tries=5){
    return withRetry(() => ch.readValue(), { tries, base: 150 });
  }

  

  const $ = id => document.getElementById(id);
  let lang = 'en';
  const statusLine = $('status');

  function fmtMs(ms){
    if (ms == null || isNaN(ms)) return '—';
    ms = Math.max(0, Math.round(ms));
    if (ms < 1000) return `${ms} ms`;
    let s = Math.floor(ms/1000);
    if (s < 60) return `${s}s`;
    let m = Math.floor(s/60); s = s % 60;
    if (m < 60) return `${m}m ${s}s`;
    let h = Math.floor(m/60); m = m % 60;
    return `${h}h ${m}m ${s}s`;
  }

    let lastStats = null;
    let lastSettings = null;

    function localizeSetName(enName, langCode = lang){
      const idxMap = { None:0, Joyful:1, Sorrowful:2, Glorious:3, Luminous:4, Chaplet:5 };
      const idx = idxMap[enName];
      if (idx == null) return enName;
      const L = i18n[langCode] || i18n.en;
      return (L.lastsets && L.lastsets[idx]) ? L.lastsets[idx] : enName;
    }

function localizeLastSetName(enName, langCode = lang) {
  const idxMap = { None:0, Joyful:1, Sorrowful:2, Glorious:3, Luminous:4, Chaplet:5 };
  const idx = idxMap[enName];
  if (idx == null) return enName;
  const L = i18n[langCode] || i18n.en;
  return (L.lastsets && L.lastsets[idx]) ? L.lastsets[idx] : enName;
}

    function renderPillsFromCache(){
      if (!lastStats || !lastSettings) return;
      const L = i18n[lang];

      const cachedName =
        (lastSettings && lastSettings.device) ||
        (lastStats && lastStats.device) ||
        (device && device.name) ||
        '—';
      $('valDevice').textContent = cachedName;
      $('valFW').textContent     = (lastSettings && lastSettings.fwVersion) || '—';

      const lastSetEN  = lastStats.lastMystery?.set;
      const lastIndex  = lastStats.lastMystery?.index;
      const lastSetLOC = lastSetEN ? localizeLastSetName(lastSetEN) : '—';
      $('valLastMystery').textContent = `${lastSetLOC}${lastIndex ? ` #${lastIndex}` : ''}`;
    }

    function relabelCharts(){
      const L = i18n[lang];

      if (barWindow?.data) {
        barWindow.data.labels = [L.chartBead, L.chartDecade, L.chartRosary, L.chartChaplet];
        // if you ever show the legend:
        // barWindow.data.datasets[0].label = L.avgLegend || 'Avg (s)';
        barWindow.update();
      }

      if (donutSets?.data) {
        donutSets.data.labels = L.sets.slice();
        donutSets.update();
      }

      if (partsChart?.data) {
        // UI order: None, Joyful, Luminous, Sorrowful, Glorious
        partsChart.data.labels = [L.sets[0], L.sets[1], L.sets[4], L.sets[2], L.sets[3]];
        partsChart.update();
      }
    }
  
  function applyI18n() {
    const L = i18n[lang];
    $('titleTxt').textContent   = L.title;
    $('connectBtn').textContent = L.connect;
    $('refreshBtn').textContent = L.refresh;
    $('resetBtn').textContent   = L.reset;
    $('disconnectBtn').textContent = L.disconnect;
    $('backupBtn').textContent  = L.backup;
    $('restoreBtn').textContent = L.restore;
    statusLine.textContent = L.statusNot;

    $('overviewTitle').textContent = L.overview;
    $('lblBeads').textContent   = L.beads;
    $('lblDecades').textContent = L.decades;
    $('lblRosaries').textContent= L.rosaries;
    $('lblChaplets').textContent= L.chaplets;

    $('avgTitle').textContent = L.averages;
    $('lblAvgBead').textContent    = L.avgBead;
    $('lblAvgDecade').textContent  = L.avgDecade;
    $('lblAvgRosary').textContent  = L.avgRosary;
    $('lblAvgChaplet').textContent = L.avgChaplet;
    $('avgNote').textContent       = L.avgNote;

    $('barTitle').textContent   = L.barTitle;
    $('donutTitle').textContent = L.donutTitle;
    $('partsTitle').textContent = L.partsTitle;
    $('bkNote').textContent     = L.bkTip;

    $('totalsTitle').textContent = L.totalsTitle;
    $('lblTbeads').textContent   = L.totBeads;
    $('lblTdecades').textContent = L.totDecades;
    $('lblTrosary').textContent  = L.totRosary;
    $('lblTchaplet').textContent = L.totChaplet;

    $('lblDevice').textContent      = L.pillDevice;
    $('lblFW').textContent          = L.pillFW;
    $('lblLastMystery').textContent = L.pillLastMystery;

    $('lblBackupRestore').textContent = L.backuprestore;

    $('settingsTitle').textContent = L.settingsTitle;
    $('lblHaptic').textContent = L.lblHaptic;
    $('descHaptic').textContent = L.descHaptic;
    $('lblPreset').textContent   = L.lblPreset;
    $('descPreset').textContent  = L.descPreset;
    $('lblAutosave').textContent = L.lblAutosave;
    $('descAutosave').textContent= L.descAutosave
    $('lblDispBright').textContent = L.lblDispBright;
    $('descDispBright').textContent = L.descDispBright;
    $('lblWallBright').textContent = L.lblWallBright;
    $('descWallBright').textContent = L.descWallBright;

    $('rcTitle').textContent = L.rcTitle;
    $('rcStatus').textContent = L.rcInactive;

    relabelCharts();
    renderPillsFromCache();
  }

  function u8ToStr(v){ return new TextDecoder().decode(v); }
  function safeNum(x, d=0){ const v = Number(x); return isFinite(v) ? v : d; }

  /* Charts */
  const barWindow = new Chart($('barWindow').getContext('2d'), {
    type: 'bar',
    data: {
      labels: ['Bead','Decade','Rosary','Chaplet'],
      datasets: [{
        label: 'Avg (s)',
        data: [0, 0, 0, 0],
        // Make chaplet visibly brown
        backgroundColor: ['#66b2ff','#66b2ff','#66b2ff','#8b5a2b']
      }]
    },
    options: {
      responsive:true, maintainAspectRatio:false,
      scales:{
        x:{ stacked:true, grid:{ color:'#1a2733' }, ticks:{ color:'#cfe4ff' } },
        y:{ stacked:true, beginAtZero:true, grid:{ color:'#1a2733' }, ticks:{ color:'#cfe4ff', precision:0 } }
      },
      plugins:{ legend:{ display:false } }
    }
  });

  const donutSets = new Chart($('donutSets').getContext('2d'), {
    type: 'doughnut',
    data: {
      labels: ['None','Joyful','Sorrowful','Glorious','Luminous','Chaplet'],
      datasets: [{
        data: [0, 0, 0, 0, 0, 0],
        backgroundColor: [
          '#808080', // None
          '#3399ff', // Joyful
          '#cc0000', // Sorrowful
          '#00cc00', // Glorious
          '#ffcc00', // Luminous
          '#8B4513'  // Chaplet (brown)
        ],
        borderColor: '#0b0f14',
        borderWidth: 2
      }]
    },
    options: {
      responsive:true,
      maintainAspectRatio:false,
      plugins:{ legend:{ position:'bottom', labels:{ color:'#eaf0f6' } } },
      cutout:'60%'
    }
  });

  const partsCtx = $('partsChart').getContext('2d');
  const partShades = {
    none:      ['#9e9e9e','#8f8f8f','#808080','#717171','#626262'],
    joyful:    ['#99ccff','#66b2ff','#3399ff','#1a7fd6','#0066cc'],
    sorrowful: ['#ff6666','#ff3333','#cc0000','#990000','#730000'],
    glorious:  ['#66ff66','#33e633','#00cc00','#00a300','#007a00'],
    luminous:  ['#ffe680','#ffdb4d','#ffcc00','#e6b800','#cc9a00'],
  };
  const partsChart = new Chart(partsCtx, {
    type: 'bar',
    data: {
      labels: ['None','Joyful','Luminous','Sorrowful','Glorious'],
      datasets: [
        { label: 'I',  data: [0,0,0,0,0], backgroundColor: [partShades.none[0],partShades.joyful[0],partShades.luminous[0],partShades.sorrowful[0],partShades.glorious[0]] },
        { label: 'II', data: [0,0,0,0,0], backgroundColor: [partShades.none[1],partShades.joyful[1],partShades.luminous[1],partShades.sorrowful[1],partShades.glorious[1]] },
        { label: 'III',data: [0,0,0,0,0], backgroundColor: [partShades.none[2],partShades.joyful[2],partShades.luminous[2],partShades.sorrowful[2],partShades.glorious[2]] },
        { label: 'IV', data: [0,0,0,0,0], backgroundColor: [partShades.none[3],partShades.joyful[3],partShades.luminous[3],partShades.sorrowful[3],partShades.glorious[3]] },
        { label: 'V',  data: [0,0,0,0,0], backgroundColor: [partShades.none[4],partShades.joyful[4],partShades.luminous[4],partShades.sorrowful[4],partShades.glorious[4]] },
      ]
    },
    options: {
      responsive:true, maintainAspectRatio:false,
      plugins:{ legend:{ position:'bottom', labels:{ color:'#eaf0f6' } } },
      scales:{
        x:{ stacked:true, grid:{ color:'#1a2733' }, ticks:{ color:'#cfe4ff' } },
        y:{ stacked:true, beginAtZero:true, grid:{ color:'#1a2733' }, ticks:{ color:'#cfe4ff', precision:0 } }
      }
    }
  });

async function waitReady(timeoutMs = 4000) {
  const start = Date.now();
  while (!readyFlag) {
    if (Date.now() - start > timeoutMs) throw new Error('BLE pacing timeout');
    await sleep(30);
  }
  // consume one permit
  readyFlag = false;
}

async function helloAndAwaitConsent(server) {
  const svc   = await server.getPrimaryService(OTA_SVC_UUID);
  const ctrl  = await svc.getCharacteristic(INFO_CTRL_UUID);
  const stat  = await svc.getCharacteristic(STATUS_UUID);

  // subscribe to status
  await stat.startNotifications();

  const result = await new Promise(async (resolve) => {
    const onStatus = (ev) => {
      const v = new Uint8Array(ev.target.value.buffer)[0];
      if (v === 0xA1) { stat.removeEventListener('characteristicvaluechanged', onStatus); resolve(true); }
      if (v === 0xA0) { stat.removeEventListener('characteristicvaluechanged', onStatus); resolve(false); }
    };
    stat.addEventListener('characteristicvaluechanged', onStatus);

    // send HELLO_WEB
    await ctrl.writeValue(Uint8Array.from([0x41]));
    // (optional) add a JS timeout to fail if no response in e.g. 25s
    setTimeout(()=>{ resolve(false); }, 25000);
  });

  if (!result) throw new Error('Device denied consent or timed out.');
}

async function connectBLE(){
  const L = i18n[lang];
  try{
    if (!navigator.bluetooth) throw new Error(L.errWB);
    statusLine.textContent = 'Requesting device…';

    let dev;
    try {
      dev = await navigator.bluetooth.requestDevice({
        filters: [{ services: [OTA_SVC_UUID] }],
        optionalServices: [OTA_SVC_UUID]
      });
    } catch {
      dev = await navigator.bluetooth.requestDevice({
        acceptAllDevices: true,
        optionalServices: [OTA_SVC_UUID]
      });
      if (!dev.name || !dev.name.toLowerCase().startsWith('rosary')) {
        throw new Error(L.errPick);
      }
    }

    device = dev;
    device.addEventListener('gattserverdisconnected', onDisconnected);

    statusLine.textContent = 'Connecting…';
    server  = await device.gatt.connect();
    await helloAndAwaitConsent(server);

    // Android settle
    await sleep(300);

    // Get service + chars
    service    = await withRetry(() => server.getPrimaryService(OTA_SVC_UUID));
    chSettings = await withRetry(() => service.getCharacteristic(INFO_SETTINGS_UUID));
    chParts    = await withRetry(() => service.getCharacteristic(INFO_PARTS_UUID));
    chStats    = await withRetry(() => service.getCharacteristic(INFO_STATS_UUID));
    chCtrl     = await withRetry(() => service.getCharacteristic(INFO_CTRL_UUID));

    // NOW wire STATUS pacing
    statusChar = await withRetry(() => service.getCharacteristic(STATUS_UUID));
    await statusChar.startNotifications();
    statusChar.addEventListener('characteristicvaluechanged', (ev) => {
      const v = new Uint8Array(ev.target.value.buffer)[0];
      if (v === 0x01) readyFlag = true; // READY tick from firmware
    });


    // Remote control characteristics (optional — don't fail connection if missing)
    try {
      touchChar = await withRetry(() => service.getCharacteristic(TOUCH_CHAR_UUID));
    } catch (e) { touchChar = null; console.warn('touchChar not found', e); }

    try {
      keysChar = await withRetry(() => service.getCharacteristic(KEYS_CHAR_UUID));
    } catch (e) { keysChar = null; console.warn('keysChar not found', e); }

    // Update UI affordances
    setDpadEnabled(!!keysChar);
    setRemoteMuted(!touchChar && !keysChar);
    rcStatus.textContent = (keysChar
      ? (i18n[lang].rcReadyTouchKeys || 'Remote ready (touch + keys).')
      : (touchChar
          ? (i18n[lang].rcReadyTouchOnly || 'Remote ready (touch only).')
          : (i18n[lang].rcInactive || 'Touch + D-pad will activate after connecting.')));

    $('refreshBtn').disabled = false;
    $('resetBtn').disabled   = false;
    $('backupBtn').disabled  = false;
    $('restoreBtn').disabled = false;
    $('disconnectBtn').disabled = true;
    $('slDispBright').disabled = false;
    $('slWallBright').disabled = false; 

    statusLine.textContent = L.statusConnected;

    // First reads with retry (smaller ones first)
    await withRetry(refresh);
    
    // 🔔 start live updates from ESP32
    await subscribeSettingsNotifs();
    subscribeSettingsNotifs();

    $('disconnectBtn').disabled = false;
    $('swHaptic').disabled = false;
    $('swPreset').disabled = false;   // NEW
    $('swAutosave').disabled = false;
    
  } catch(err){
    console.error(err);
    statusLine.textContent = 'Error: ' + err.message;
  }
}

async function refresh(){
  const L = i18n[lang];
  let ok = false;

  try{
    if (!chStats || !chSettings) return false;

    // small settle for Android
    await sleep(200);

    // Read small blobs first
    const [vSettings, vPartsMaybe] = await Promise.all([
      robustRead(chSettings),
      chParts ? robustRead(chParts).catch(()=>null) : Promise.resolve(null)
    ]);

    // Then stats (largest)
    await sleep(80);
    const vStats = await robustRead(chStats);

    // Decode
    const rawSettings = u8ToStr(vSettings);
    const rawStats    = u8ToStr(vStats);
    const rawParts    = vPartsMaybe ? u8ToStr(vPartsMaybe) : null;

    // Bail quietly if firmware hasn’t rebuilt JSON yet
    if (!rawSettings || !rawSettings.trim() || rawSettings.trim() === '{}') return false;
    if (!rawStats    || !rawStats.trim()    || rawStats.trim()    === '{}') return false;

    // Parse with guardrails
    let jsSettings, jsStats, jsParts = null;
    try { jsSettings = JSON.parse(rawSettings); } catch { return false; }
    try { jsStats    = JSON.parse(rawStats);    } catch { return false; }
    if (rawParts != null) {
      try { jsParts = JSON.parse(rawParts); } catch { jsParts = null; }
    }

    // Cache for re-localization
    lastStats    = jsStats;
    lastSettings = jsSettings;

    // ---- UI updates ----
    $('kpiBeads').textContent    = (jsStats.totals?.beads ?? '—');
    $('kpiDecades').textContent  = (jsStats.totals?.decades ?? '—');
    $('kpiRosaries').textContent = (jsStats.totals?.rosaries ?? '—');
    $('kpiChaplets').textContent = (jsStats.totals?.chaplets ?? '—');

    const devName =
      (jsSettings && jsSettings.device) ||
      (jsStats && jsStats.device) ||
      (device && device.name) ||
      '—';
    $('valDevice').textContent = devName;
    $('valFW').textContent     = jsSettings.fwVersion || '—';

    const lastSetEN  = jsStats.lastMystery?.set;
    const lastIndex  = jsStats.lastMystery?.index;
    const lastSetLOC = lastSetEN ? localizeLastSetName(lastSetEN) : '—';
    $('valLastMystery').textContent = `${lastSetLOC}${lastIndex ? ` #${lastIndex}` : ''}`;

    const d = jsStats.durations || {};
    const avgBeadMs     = safeNum(d.avgBeadMs,     0);
    const avgDecadeMs   = safeNum(d.avgDecadeMs,   0);
    const avgRosaryMs   = safeNum(d.avgRosaryMs,   0);
    const avgChapletMs  = safeNum(d.avgChapletMs,  0);
    const totBeadMs     = safeNum(d.totalBeadMs,     0);
    const totDecadeMs   = safeNum(d.totalDecadeMs,   0);
    const totRosaryMs   = safeNum(d.totalRosaryMs,   0);
    const totChapletMs  = safeNum(d.totalChapletMs,  0);

    $('kpiAvgBead').textContent     = fmtMs(avgBeadMs);
    $('kpiAvgDecade').textContent   = fmtMs(avgDecadeMs);
    $('kpiAvgRosary').textContent   = fmtMs(avgRosaryMs);
    $('kpiAvgChaplet').textContent  = fmtMs(avgChapletMs);

    $('totRosary').textContent  = fmtMs(totRosaryMs);
    $('totDecade').textContent  = fmtMs(totDecadeMs);
    $('totBead').textContent    = fmtMs(totBeadMs);
    $('totChaplet').textContent = fmtMs(totChapletMs);

    barWindow.data.datasets[0].data = [
      avgBeadMs/1000,
      avgDecadeMs/1000,
      avgRosaryMs/1000,
      avgChapletMs/1000
    ];
    barWindow.update();

    const totalDec = (jsStats.totals?.decades ?? 0);
    const joyful   = (jsStats.sets?.joyful ?? 0);
    const sorrow   = (jsStats.sets?.sorrowful ?? 0);
    const glor     = (jsStats.sets?.glorious ?? 0);
    const lumi     = (jsStats.sets?.luminous ?? 0);
    const chap     = (jsStats.totals?.chaplets ?? 0);
    let none       = jsStats.sets?.none;
    if (none == null) {
      const sumKnown = joyful + sorrow + glor + lumi;
      none = Math.max(0, totalDec - sumKnown);
    }
    donutSets.data.datasets[0].data = [none, joyful, sorrow, glor, lumi, chap];
    donutSets.update();

    if (jsParts) {
      const sp = jsParts.setsParts || {};
      const setsOrder = ['none','joyful','luminous','sorrowful','glorious']; // UI order
      const dataByPart = [0,1,2,3,4].map(()=>[0,0,0,0,0]);
      setsOrder.forEach((name, si) => {
        const arr = sp[name] || [0,0,0,0,0];
        for (let p=0;p<5;p++) dataByPart[p][si] = Number(arr[p]||0);
      });
      for (let p=0;p<5;p++) partsChart.data.datasets[p].data = dataByPart[p];
      partsChart.update();
    }

    renderPillsFromCache();

    $('swHaptic').checked   = !!jsSettings.haptic;
    $('swPreset').checked   = !!(jsSettings.mystery?.preset);
    $('swAutosave').checked = !!(jsSettings.mystery && jsSettings.mystery.autosave);

    const db = Math.max(0, Math.min(100, Number(jsSettings.display?.brightness ?? 0)));
    $('slDispBright').value = db;
    $('slDispBrightVal').textContent = db + '%';

    const wb = Math.max(0, Math.min(100, Number(jsSettings.wallpaper?.brightness ?? 0)));
    $('slWallBright').value = wb;
    $('wallBrightVal').textContent = wb + '%';

    statusLine.textContent = L.statusUpdated;
    ok = true;
    return true;

  } catch(err){
    console.error(err);
    statusLine.textContent = 'Read failed: ' + err.message;
    return ok; // false unless we already updated successfully
  }
}

  async function resetStats(){
    const L = i18n[lang];
    try{
      if (!chCtrl) return;
      if (!confirm(L.confirmReset)) return;
      await chCtrl.writeValue(new Uint8Array([0x01]));
      await waitReady();
      setTimeout(refresh, 300);
      statusLine.textContent = L.statusResetReq;
    } catch(err){
      console.error(err);
      statusLine.textContent = 'Reset failed: ' + err.message;
    }
  }

  function onDisconnected(){
    const L = i18n[lang];
    statusLine.textContent = L.statusDisconnected;
    $('refreshBtn').disabled = true;
    $('resetBtn').disabled   = true;
    $('disconnectBtn').disabled = true;
    $('backupBtn').disabled  = true;
    $('restoreBtn').disabled = true;
    $('swHaptic').disabled   = true;
    $('swAutosave').disabled = true;
    $('swPreset').disabled   = true;
    $('slDispBright').disabled = true;
    $('slWallBright').disabled = true; 
    touchChar = null; keysChar = null;
    setDpadEnabled(false);
    setRemoteMuted(true);
    rcStatus.textContent = i18n[lang].rcInactive;
  }

  async function disconnectBLE(){
    try { if (device && device.gatt.connected) await device.gatt.disconnect(); }
    catch (e) { console.warn(e); }
    finally { onDisconnected(); }
  }
  

  // --- helpers for flaky Android GATT reads ---
async function reacquireChars() {
  // Re-fetch service & characteristics from the current server
  service    = await withRetry(() => server.getPrimaryService(OTA_SVC_UUID));
  chSettings = await withRetry(() => service.getCharacteristic(INFO_SETTINGS_UUID));
  // parts is optional
  try { chParts = await withRetry(() => service.getCharacteristic(INFO_PARTS_UUID)); }
  catch { chParts = null; }
  chStats    = await withRetry(() => service.getCharacteristic(INFO_STATS_UUID));
  chCtrl     = await withRetry(() => service.getCharacteristic(INFO_CTRL_UUID));
}

async function robustRead(ch) {
  // Try a normal read
  try { return await readWithRetry(ch); }
  catch (e1) {
    console.warn('read failed once, reacquiring chars…', e1);
    // Reacquire handles (Android sometimes invalidates them)
    await sleep(200);
    await reacquireChars();
    try { return await readWithRetry(ch); }
    catch (e2) {
      console.warn('read failed after reacquire, reconnecting…', e2);
      // Full reconnect, then reacquire and retry once more
      try { if (device?.gatt?.connected) device.gatt.disconnect(); } catch {}
      await sleep(250);
      server = await device.gatt.connect();
      await sleep(300);
      await reacquireChars();
      return await readWithRetry(ch);
    }
  }
}

// ---- Backup (Android friendly: paced reads + reacquire/reconnect fallback) ----
async function doBackup(){
  const L = i18n[lang];
  try{
    if (!chStats || !chSettings) return;
    statusLine.textContent = L.backupStart();

    // small settle
    await sleep(150);

    // Read smaller blobs first, then the larger stats (each via robustRead)
    const vSettings = await robustRead(chSettings);

    let vParts = null;
    if (chParts) {
      try { vParts = await robustRead(chParts); }
      catch (e) { console.warn('parts read skipped:', e); }
    }

    await sleep(80);
    const vStats = await robustRead(chStats);

    const jsStats    = JSON.parse(u8ToStr(vStats));
    const jsSettings = JSON.parse(u8ToStr(vSettings));

    // Ensure duration counters exist for reliable restore of averages
    const d = jsStats?.durations || {};
    const beadSum = Number(d.totalBeadMs ?? 0);
    const decSum  = Number(d.totalDecadeMs ?? 0);
    const rosSum  = Number(d.totalRosaryMs ?? 0);
    const chapSum = Number(d.totalChapletMs ?? 0);

    let beadCnt = Number(d.beadIntervals || 0);
    let decCnt  = Number(d.decadeCount   || 0);
    let rosCnt  = Number(d.rosaryCount   || 0);
    let chapCnt = Number(jsStats.totals?.chaplets ?? d.chapletCount ?? 0);

    if (!beadCnt) {
      const avg = Number(d.avgBeadMs || 0);
      beadCnt = avg > 0 ? Math.floor(beadSum / avg) : 0;
    }
    if (!decCnt) {
      const avg = Number(d.avgDecadeMs || 0);
      decCnt = avg > 0 ? Math.floor(decSum / avg) : 0;
    }
    if (!rosCnt) {
      const avg = Number(d.avgRosaryMs || 0);
      rosCnt = avg > 0 ? Math.floor(rosSum / avg) : 0;
    }
    if (!chapCnt) {
      const avg = Number(d.avgChapletMs || 0);
      chapCnt = avg > 0 ? Math.floor(chapSum / avg) : 0;
    }


    jsStats.durations = {
      ...d,
      beadIntervals: beadCnt,
      decadeCount:   decCnt,
      rosaryCount:   rosCnt,
      chapletCount:  chapCnt,
      totalBeadMs:   String(beadSum),
      totalDecadeMs: String(decSum),
      totalRosaryMs: String(rosSum),
      totalChapletMs:  String(chapSum)
      // chaplet fields (if your firmware emits them) will be kept as-is
    };

    const js = {
      device:    jsStats.device || '',
      fwVersion: jsSettings.fwVersion || '',
      stats:     jsStats,
      settings:  jsSettings,
      setsParts: null
    };

    if (vParts) {
      try {
        const jp = JSON.parse(u8ToStr(vParts));
        js.setsParts = jp.setsParts || null;
      } catch(e) {
        console.warn('Parts JSON parse skipped:', e);
      }
    }

    const blob = new Blob([JSON.stringify(js, null, 2)], { type: 'application/json' });
    const url  = URL.createObjectURL(blob);
    const a    = document.createElement('a');
    a.href = url;
    a.download = (js.device || 'rosary') + '_backup.json';
    a.click();
    URL.revokeObjectURL(url);

    statusLine.textContent = L.backupDone;
  } catch(err){
    console.error(err);
    statusLine.textContent = 'Backup failed: ' + err.message;
  }
}

async function subscribeSettingsNotifs(){
  if (!chSettings) return;
  await chSettings.startNotifications();
  chSettings.addEventListener('characteristicvaluechanged', onSettingsNotif);
}

let updatingFromDevice = false;

$('swPreset').addEventListener('change', async (e) => {
  if (updatingFromDevice) return;
  try {
    // optimistic UI
    $('swAutosave').disabled = e.target.checked;
    await writePrefKey("m-preset-en", 0x01, e.target.checked ? 1 : 0);
    statusLine.textContent = (i18n[lang].settingsSaved || i18n[lang].statusUpdated);
  } catch (err) {
    console.error(err);
    statusLine.textContent = 'Write failed: ' + err.message;
  }
});

$('swAutosave').addEventListener('change', async (e) => {
  if (updatingFromDevice) return;
  try {
    // optimistic UI
    $('swPreset').disabled = e.target.checked;
    await writePrefKey("m-autosave-en", 0x01, e.target.checked ? 1 : 0);
    statusLine.textContent = (i18n[lang].settingsSaved || i18n[lang].statusUpdated);
  } catch (err) {
    console.error(err);
    statusLine.textContent = 'Write failed: ' + err.message;
  }
});

let brDebounce = null;
$('slDispBright').addEventListener('input', (e) => {
  // always update the label immediately
  $('slDispBrightVal').textContent = e.target.value + '%';
  if (updatingFromDevice) return; // ignore programmatic updates

  const val = Math.max(0, Math.min(100, Number(e.target.value|0)));

  // debounce BLE write
  if (brDebounce) clearTimeout(brDebounce);
  brDebounce = setTimeout(async () => {
    try {
      await writePrefKey("disp-bright", 0x21, val);   // int32
      statusLine.textContent = (i18n[lang].settingsSaved || i18n[lang].statusUpdated);
    } catch (err) {
      console.error(err);
      statusLine.textContent = 'Write failed: ' + err.message;
    }
  }, 140); // feel free to tweak
});

let wbDebounce = null;
$('slWallBright').addEventListener('input', (e) => {
  $('wallBrightVal').textContent = e.target.value + '%';
  if (updatingFromDevice) return;

  const val = Math.max(0, Math.min(100, Number(e.target.value|0)));
  if (wbDebounce) clearTimeout(wbDebounce);
  wbDebounce = setTimeout(async () => {
    try {
      await writePrefKey("wall-bright", 0x21, val); // int32
      statusLine.textContent = (i18n[lang].settingsSaved || i18n[lang].statusUpdated);
    } catch (err) {
      console.error(err);
      statusLine.textContent = 'Write failed: ' + err.message;
    }
  }, 140);
});

function onSettingsNotif(ev){
  try{
    const dv = ev.target.value; // DataView
    const u8 = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
    const js = JSON.parse(new TextDecoder().decode(u8));

    // cache + UI
    lastSettings = js;

    // prevent feedback loop when we programmatically flip the web switch
    updatingFromDevice = true;

    const sw = document.getElementById('swHaptic');
    if (sw) sw.checked = !!js.haptic;

    const swP = $('swPreset');
    const swA = $('swAutosave');

    if (swP) swP.checked = !!(js.mystery?.preset);
    if (swA) swA.checked = !!(js.mystery && js.mystery.autosave);

    // mirror dependency in UI
    if (swP && swA) {
      swA.disabled = swP.checked;
      swP.disabled = swA.checked ? true : false; // optional symmetry
    }

    const db = Math.max(0, Math.min(100, Number(js.display?.brightness ?? 0)));
    const sl = $('slDispBright');
    const sv = $('slDispBrightVal');
    if (sl && sv) {
      updatingFromDevice = true;
      sl.value = db;
      sv.textContent = db + '%';
      updatingFromDevice = false;
    }

    const wbN = Math.max(0, Math.min(100, Number(js.wallpaper?.brightness ?? 0)));
    const slw = $('slWallBright');
    const wv  = $('wallBrightVal');
    if (slw && wv) {
      updatingFromDevice = true;
      slw.value = wbN;
      wv.textContent = wbN + '%';
      updatingFromDevice = false;
    }

    updatingFromDevice = false;

    // update pills/labels that depend on settings (FW version etc.)
    document.getElementById('valFW').textContent = js.fwVersion || '—';
  } catch(e){ console.warn('settings notif parse failed', e); }
}

  // ---- Restore (upload JSON -> many small SET_* writes) ----
  function le16(n){ const a=new Uint8Array(2); n=Number(n)>>>0; a[0]=n&255; a[1]=(n>>8)&255; return a; }
  function le32(n){ const a=new Uint8Array(4); n = Number(n)>>>0; a[0]=n&255; a[1]=(n>>8)&255; a[2]=(n>>16)&255; a[3]=(n>>24)&255; return a; }
  function le64Big(n){ const a = new Uint8Array(8); let x = BigInt(n); for (let i=0;i<8;i++){ a[i] = Number(x & 0xffn); x >>= 8n; } return a; }
  function packKV(op, type, key, valBytes){
    const k = new TextEncoder().encode(key);
    const out = new Uint8Array(1 + 1 + 1 + k.length + valBytes.length);
    out[0]=op; out[1]=type; out[2]=k.length; out.set(k,3); out.set(valBytes, 3+k.length);
    return out;
  }
  function encSize(type, value){
    switch (type){
      case 0x01: return 1; case 0x11: return 1; case 0x12: return 2; case 0x14: return 4; case 0x21: return 4; case 0x18: return 8;
      case 0x31: return new TextEncoder().encode(String(value)).length; default: throw new Error('bad type');
    }
  }

  async function writePrefKey(key, type, value){
    let valBytes;
    switch (type){
      case 0x01: valBytes = new Uint8Array([value?1:0]); break;
      case 0x11: valBytes = new Uint8Array([Number(value) & 0xff]); break;
      case 0x12: { const v=Number(value)>>>0; valBytes = new Uint8Array([v & 0xff, (v>>8)&0xff]); } break;
      case 0x14: valBytes = le32(value); break;
      case 0x21: valBytes = le32(value); break;
      case 0x18: valBytes = le64Big(BigInt(value)); break;
      case 0x31: valBytes = new TextEncoder().encode(String(value)); break;
      default: throw new Error('bad type');
    }
    const payload = packKV(OP_SET_PREF, type, key, valBytes);
    await chCtrl.writeValue(payload);
    await waitReady();                 // <-- ADD
  }

  async function writeStatKey(key, type, value){
    let valBytes;
    switch (type){
      case 0x11: valBytes = new Uint8Array([Number(value) & 0xff]); break;
      case 0x12: { const v=Number(value)>>>0; valBytes = new Uint8Array([v & 0xff, (v>>8)&0xff]); } break;
      case 0x14: valBytes = le32(value); break;
      case 0x18: valBytes = le64Big(BigInt(value)); break;
      default: throw new Error('bad type');
    }
    const payload = packKV(OP_SET_STAT, type, key, valBytes);
    await chCtrl.writeValue(payload);
    await waitReady();                 // <-- ADD
  }

  async function restoreFromJson(js, onProgress){
  // prefs mapping per Settings::load()
  const prefs = js.settings || js.prefs || {};
  const stAll = js.stats || {};

  // ----- cache once, no redeclarations later -----
  const totalsObj = stAll.totals || {};
  const lastObj   = stAll.lastMystery || {};
  const setsObj   = stAll.sets || {};
  const ringArr   = stAll.ring || [];
  const partsObj  = js.setsParts || stAll.setsParts || {};
  const durObj    = stAll.durations || {};

  // include Chaplet for completeness (even if device ignores it for “lastSet” legacy)
  const setMap = { None:0, Joyful:1, Luminous:2, Sorrowful:3, Glorious:4, Chaplet:5 };

  const order = ['none','joyful','luminous','sorrowful','glorious'];

  const totalSteps =
    13 + // prefs
    5 + 3 + 2 + 30 + 5 + (5*5) + 8; // <-- was 6
  let step=0;
  const tick = ()=>onProgress?.(++step, totalSteps);

  // ---- PREPASS: compute totalBytes for RESTORE_BEGIN ----
  let totalBytes = 0;
  const sumKV = (key, type, value) => { totalBytes += key.length + encSize(type, value); };

  // prefs booleans
  sumKV("haptic-en",     0x01, !!prefs.haptic);
  sumKV("m-preset-en",   0x01, !!(prefs.mystery?.preset));
  sumKV("m-autosave-en", 0x01, !!(prefs.mystery?.autosave));
  sumKV("m-intro-en",    0x01, !!(prefs.mystery?.intro));
  sumKV("i-en",          0x01, !!(prefs.intentions?.enabled));

  // prefs ints
  sumKV("disp-bright",   0x21, prefs.display?.brightness ?? 0);
  sumKV("disp-rot",      0x21, prefs.display?.rotation ?? 0);
  sumKV("wall-bright",   0x21, prefs.wallpaper?.brightness ?? 0);
  sumKV("ImageIndex",    0x21, prefs.wallpaper?.imageIndex ?? 0);
  sumKV("beadIndex",     0x21, prefs.mystery?.beadIndex ?? -1);
  sumKV("m-pos",         0x21, prefs.mystery?.pos ?? 0);
  sumKV("m-part",        0x21, prefs.mystery?.part ?? 0);
  sumKV("i-pos",         0x21, prefs.intentions?.pos ?? 0);

  // stats scalars
  sumKV("beads",    0x14, totalsObj.beads    ?? 0);
  sumKV("paters",   0x14, totalsObj.paters   ?? 0);
  sumKV("glorias",  0x14, totalsObj.glorias  ?? 0);
  sumKV("decades",  0x14, totalsObj.decades  ?? 0);
  sumKV("rosaries", 0x14, totalsObj.rosaries ?? 0);

  // last mystery + ts
  sumKV("lastSet", 0x11, setMap[lastObj.set] ?? 0);
  sumKV("lastIdx", 0x11, lastObj.index ?? 0);
  sumKV("lastTs",  0x14, stAll.lastPrayer ?? 0);

  // streak + baseDay
  sumKV("streak",  0x12, stAll.streakDays ?? 0);
  sumKV("baseDay", 0x14, 0);

  // ring[30]
  for (let i=0;i<30;i++){
    const key = `r${String(i).padStart(2,'0')}`;
    sumKV(key, 0x12, ringArr[i] ?? 0);
  }

  // sets totals set0..set4
  for (let si=0; si<5; si++){
    sumKV(`set${si}`, 0x14, setsObj[order[si]] ?? 0);
  }

  // parts pXY
  for (let si=0; si<5; si++){
    const arr = partsObj[order[si]] || [0,0,0,0,0];
    for (let pi=0; pi<5; pi++){
      sumKV(`p${si}${pi}`, 0x14, arr[pi] ?? 0);
    }
  }

  // durations: sums+counts
  sumKV("bSum", 0x18, BigInt(durObj.totalBeadMs   ?? 0));
  sumKV("bInt", 0x14, (durObj.beadIntervals ?? 0));
  sumKV("dSum", 0x18, BigInt(durObj.totalDecadeMs ?? 0));
  sumKV("dCnt", 0x14, (durObj.decadeCount  ?? 0));
  sumKV("rSum", 0x18, BigInt(durObj.totalRosaryMs ?? 0));
  sumKV("rCnt", 0x14, (durObj.rosaryCount  ?? 0));
  // NEW — Chaplet:
  sumKV("cSum", 0x18, BigInt(durObj.totalChapletMs ?? 0));
  sumKV("cCnt", 0x14, (stAll.totals?.chaplets ?? durObj.chapletCount ?? 0));

  // Send RESTORE_BEGIN so ESP32 can display progress based on bytes
  const begin = new Uint8Array(1+2+4);
  begin[0] = OP_REST_BEGIN;
  begin.set(le16(totalSteps), 1);
  begin.set(le32(totalBytes), 3);
  await chCtrl.writeValue(begin);
  try { await waitReady(); } catch { readyFlag = true; /* proceed to first KV */ }

  // ---- ACTUAL WRITES ----

  // prefs booleans
  await writePrefKey("haptic-en",     0x01, !!prefs.haptic);                     tick();
  await writePrefKey("m-preset-en",   0x01, !!(prefs.mystery?.preset));          tick();
  await writePrefKey("m-autosave-en", 0x01, !!(prefs.mystery?.autosave));        tick();
  await writePrefKey("m-intro-en",    0x01, !!(prefs.mystery?.intro));           tick();
  await writePrefKey("i-en",          0x01, !!(prefs.intentions?.enabled));      tick();

  // prefs ints
  await writePrefKey("disp-bright",   0x21, prefs.display?.brightness ?? 0);     tick();
  await writePrefKey("disp-rot",      0x21, prefs.display?.rotation ?? 0);       tick();
  await writePrefKey("wall-bright",   0x21, prefs.wallpaper?.brightness ?? 0);   tick();
  await writePrefKey("ImageIndex",    0x21, prefs.wallpaper?.imageIndex ?? 0);   tick();
  await writePrefKey("beadIndex",     0x21, prefs.mystery?.beadIndex ?? -1);     tick();
  await writePrefKey("m-pos",         0x21, prefs.mystery?.pos ?? 0);            tick();
  await writePrefKey("m-part",        0x21, prefs.mystery?.part ?? 0);           tick();
  await writePrefKey("i-pos",         0x21, prefs.intentions?.pos ?? 0);         tick();

  // stats scalars
  await writeStatKey("beads",    0x14, totalsObj.beads    ?? 0); tick();
  await writeStatKey("paters",   0x14, totalsObj.paters   ?? 0); tick();
  await writeStatKey("glorias",  0x14, totalsObj.glorias  ?? 0); tick();
  await writeStatKey("decades",  0x14, totalsObj.decades  ?? 0); tick();
  await writeStatKey("rosaries", 0x14, totalsObj.rosaries ?? 0); tick();

  // last mystery + ts (legacy)
  await writeStatKey("lastSet", 0x11, setMap[lastObj.set] ?? 0);     tick();
  await writeStatKey("lastIdx", 0x11, lastObj.index ?? 0);           tick();
  await writeStatKey("lastTs",  0x14, stAll.lastPrayer ?? 0);        tick();

  // streak + baseDay
  await writeStatKey("streak",  0x12, stAll.streakDays ?? 0);        tick();
  await writeStatKey("baseDay", 0x14, 0);                            tick();

  // ring[30]
  for (let i=0;i<30;i++){
    const key = `r${String(i).padStart(2,'0')}`;
    await writeStatKey(key, 0x12, ringArr[i] ?? 0);                  tick();
  }

  // sets totals set0..set4
  for (let si=0; si<5; si++){
    await writeStatKey(`set${si}`, 0x14, setsObj[order[si]] ?? 0);   tick();
  }

  // parts pXY
  for (let si=0; si<5; si++){
    const arr = partsObj[order[si]] || [0,0,0,0,0];
    for (let pi=0; pi<5; pi++){
      await writeStatKey(`p${si}${pi}`, 0x14, arr[pi] ?? 0);         tick();
    }
  }

  // durations: sums+counts
  await writeStatKey("bSum", 0x18, BigInt(durObj.totalBeadMs   ?? 0)); tick();
  await writeStatKey("bInt", 0x14, (durObj.beadIntervals ?? 0));       tick();
  await writeStatKey("dSum", 0x18, BigInt(durObj.totalDecadeMs ?? 0)); tick();
  await writeStatKey("dCnt", 0x14, (durObj.decadeCount  ?? 0));        tick();
  await writeStatKey("rSum", 0x18, BigInt(durObj.totalRosaryMs ?? 0)); tick();
  await writeStatKey("rCnt", 0x14, (durObj.rosaryCount  ?? 0));        tick();
  // NEW — Chaplet:
  await writeStatKey("cSum", 0x18, BigInt(durObj.totalChapletMs ?? 0));                    tick();
  await writeStatKey("cCnt", 0x14, (stAll.totals?.chaplets ?? durObj.chapletCount ?? 0));  tick();
  

  // ask device to refresh JSON chars
  await chCtrl.writeValue(new Uint8Array([OP_REST_DONE]));
  await waitReady(); 
}

async function refreshUntilValid({tries=8, delay=250} = {}) {
  for (let i=0;i<tries;i++){
    const ok = await refresh();
    if (ok) return true;
    await sleep(delay * Math.pow(1.4, i));
    if (i === 2) { try { await reacquireChars(); } catch {} }
  }
  return false;
}

async function subscribeDataNotifs(){
  if (chStats)   { await chStats.startNotifications();
    chStats.addEventListener('characteristicvaluechanged', () => refresh()); }
  if (chParts)   { await chParts.startNotifications();
    chParts.addEventListener('characteristicvaluechanged', () => refresh()); }
}

  // UI wiring
  $('connectBtn').addEventListener('click', connectBLE);
  $('refreshBtn').addEventListener('click', refresh);
  $('resetBtn').addEventListener('click', resetStats);
  $('disconnectBtn').addEventListener('click', disconnectBLE);
  $('backupBtn').addEventListener('click', doBackup);

  $('restoreBtn').addEventListener('click', () => $('restoreFile').click());
  $('restoreFile').addEventListener('change', async (e)=>{
    const f = e.target.files[0];
    if (!f) return;
    const L = i18n[lang];
    const prog = $('restoreProg'); prog.hidden = false; prog.value = 0;
    const text = await f.text();
    let js;
    try { js = JSON.parse(text); } catch { alert('Bad JSON'); prog.hidden=true; return; }
    statusLine.textContent = L.restoreStart;
    const onProg = (step,total)=>{ prog.value = Math.floor(step*100/total); };
    try{
      await restoreFromJson(js, onProg);
      await refreshUntilValid({ tries: 12, delay: 250 });
      statusLine.textContent = L.restoreDone;
    } catch(err){
      console.error(err);
      statusLine.textContent = 'Restore failed: ' + err.message;
    } finally {
      setTimeout(()=>{ prog.hidden = true; }, 600);
      e.target.value = '';
    }
  });

  // Language selector
  $('langSelect').addEventListener('change', (ev)=>{ lang = ev.target.value; applyI18n(); });

  $('swHaptic').addEventListener('change', async (e) => {
    if (updatingFromDevice) return; // ignore programmatic flips from ESP32
    try {
      // bool → type 0x01 (as you already handle in INFO_CTRL)
      await writePrefKey("haptic-en", 0x01, e.target.checked ? 1 : 0);
      const L = i18n[lang];
      statusLine.textContent = L.settingsSaved || L.statusUpdated;
    } catch (err) {
      console.error(err);
      statusLine.textContent = 'Write failed: ' + err.message;
    }
  });

// 5-byte touch: [xHi,xLo,yHi,yLo,state]
function sendTouch(x, y, down) {
  if (!touchChar) return;
  const buf = new ArrayBuffer(5);
  const v   = new DataView(buf);
  v.setUint16(0, x, false); // big-endian to match LVGL demo; flip if your FW expects LE
  v.setUint16(2, y, false);
  v.setUint8 (4, down ? 1 : 0);
  // Prefer Write Without Response, fall back to Write
  touchChar.writeValueWithoutResponse(buf).catch(async () => {
    try { await touchChar.writeValue(buf); } catch(_) {}
  });
}

// 1-byte key/dir/cmd
function sendKey(byte) {
  if (!keysChar) return;
  const buf = new Uint8Array([byte & 0xFF]);
  keysChar.writeValueWithoutResponse(buf).catch(async () => {
    try { await keysChar.writeValue(buf); } catch(_) {}
  });
}

// Pointer helpers for round canvas
function canvasXY(e) {
  const r  = canvasRC.getBoundingClientRect();
  const sx = canvasRC.width  / r.width;
  const sy = canvasRC.height / r.height;
  const x  = Math.round((e.clientX - r.left) * sx);
  const y  = Math.round((e.clientY - r.top)  * sy);
  return { x, y };
}
function clampToCircle(x, y) {
  const W = canvasRC.width, H = canvasRC.height;
  const cx = W / 2, cy = H / 2;
  const dx = x - cx, dy = y - cy;
  const r  = Math.min(W, H) / 2;
  const d2 = dx*dx + dy*dy;
  if (d2 <= r*r) return { x: Math.round(x), y: Math.round(y) };
  const d = Math.sqrt(d2) || 1;
  const k = r / d;
  return { x: Math.round(cx + dx * k), y: Math.round(cy + dy * k) };
}

// Round-canvas pointer events (guarded by touchChar in sendTouch)
let rcIsDown = false;
canvasRC.addEventListener('pointermove', (e) => {
  const {x, y} = canvasXY(e);
  const p = clampToCircle(x, y);
  const down = e.pointerType === 'mouse' ? !!e.buttons : rcIsDown;
  sendTouch(p.x, p.y, down);
  e.preventDefault();
}, { passive:false });

canvasRC.addEventListener('pointerdown', (e) => {
  rcIsDown = true; canvasRC.setPointerCapture(e.pointerId);
  const {x, y} = canvasXY(e);
  const p = clampToCircle(x, y);
  sendTouch(p.x, p.y, true);
  e.preventDefault();
}, { passive:false });

function rcEndPointer(e){
  rcIsDown = false;
  const {x, y} = canvasXY(e);
  const p = clampToCircle(x, y);
  sendTouch(p.x, p.y, false);
  e.preventDefault();
}
canvasRC.addEventListener('pointerup', rcEndPointer, { passive:false });
canvasRC.addEventListener('pointercancel', rcEndPointer, { passive:false });
canvasRC.addEventListener('pointerleave', rcEndPointer, { passive:false });
canvasRC.addEventListener('contextmenu', (e) => e.preventDefault());

// D-pad buttons
btnUp    .addEventListener('pointerdown', e => { sendKey(LV.TOP);    e.preventDefault(); });
btnDown  .addEventListener('pointerdown', e => { sendKey(LV.BOTTOM); e.preventDefault(); });
btnLeft  .addEventListener('pointerdown', e => { sendKey(LV.LEFT);   e.preventDefault(); });
btnRight .addEventListener('pointerdown', e => { sendKey(LV.RIGHT);  e.preventDefault(); });
btnCenter.addEventListener('pointerdown', e => { sendKey(CMD_CENTER); e.preventDefault(); });

// Optional desktop keys
window.addEventListener('keydown', (e) => {
  if (e.repeat) return;
  if (e.key === 'Enter' || e.key === ' ') { sendKey(CMD_CENTER); e.preventDefault(); }
  if (e.key === 'ArrowUp')    { sendKey(LV.TOP);    e.preventDefault(); }
  if (e.key === 'ArrowDown')  { sendKey(LV.BOTTOM); e.preventDefault(); }
  if (e.key === 'ArrowLeft')  { sendKey(LV.LEFT);   e.preventDefault(); }
  if (e.key === 'ArrowRight') { sendKey(LV.RIGHT);  e.preventDefault(); }
});

  // Initial i18n
  lang = 'pl';
  applyI18n();
  </script>
</body>
</html>